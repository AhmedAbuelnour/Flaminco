<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keycloak Integration Guide for ASP.NET Core - Complete Documentation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .toc {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 40px;
            border-left: 4px solid #667eea;
        }

        .toc h2 {
            color: #667eea;
            margin-bottom: 20px;
        }

        .toc ul {
            list-style: none;
        }

        .toc li {
            margin: 10px 0;
        }

        .toc a {
            color: #333;
            text-decoration: none;
            padding: 8px 12px;
            display: block;
            border-radius: 4px;
            transition: all 0.3s;
        }

        .toc a:hover {
            background: #667eea;
            color: white;
            transform: translateX(5px);
        }

        section {
            margin-bottom: 50px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        section h2 {
            color: #667eea;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        section h3 {
            color: #764ba2;
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        section h4 {
            color: #555;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .step {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 6px;
            border-left: 3px solid #667eea;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .step-number {
            display: inline-block;
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            margin-right: 10px;
        }

        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 30px 40px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 25px 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 1.1em;
            line-height: 2.0;
            border: 1px solid #3e3e3e;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            position: relative;
            word-spacing: normal;
            letter-spacing: 0.5px;
            white-space: pre;
        }

        .code-block code {
            color: #d4d4d4;
            font-size: inherit;
            line-height: inherit;
            white-space: pre;
            display: block;
        }

        .code-block::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 8px 8px 0 0;
        }

        .keyword { 
            color: #c586c0; 
            font-weight: 500;
        }
        .string { 
            color: #ce9178; 
        }
        .comment { 
            color: #6a9955; 
            font-style: italic;
        }
        .function { 
            color: #dcdcaa; 
            font-weight: 500;
        }
        .type { 
            color: #4ec9b0; 
            font-weight: 500;
        }
        
        /* Improve spacing in code blocks */
        .code-block span {
            display: inline;
            margin: 0;
            padding: 0;
        }
        
        /* Better visual separation for code blocks */
        .code-block + .code-block {
            margin-top: 30px;
        }

        /* Inline code styling */
        code:not(.code-block code) {
            background: #f4f4f4;
            color: #e83e8c;
            padding: 3px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            font-weight: 500;
            border: 1px solid #e0e0e0;
        }

        /* Ensure code blocks have proper spacing - consolidated into main .code-block rule */

        /* Improve readability of nested elements in code */
        .code-block .keyword,
        .code-block .string,
        .code-block .comment,
        .code-block .function,
        .code-block .type {
            padding: 0 2px;
        }

        /* Custom scrollbar for code blocks */
        .code-block::-webkit-scrollbar {
            height: 10px;
        }

        .code-block::-webkit-scrollbar-track {
            background: #2d2d2d;
            border-radius: 5px;
        }

        .code-block::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 5px;
        }

        .code-block::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }

        /* Add subtle hover effect */
        .code-block:hover {
            border-color: #667eea;
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.2);
        }

        /* Better spacing for code block content */
        .code-block pre {
            margin: 0;
            padding: 0;
            font-family: inherit;
            font-size: inherit;
            line-height: inherit;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .success-box {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .danger-box {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
        }

        table th, table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        table th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        table tr:hover {
            background: #f5f5f5;
        }

        .architecture-diagram {
            background: white;
            padding: 20px;
            border-radius: 6px;
            margin: 20px 0;
            text-align: center;
        }

        .architecture-box {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 15px 25px;
            margin: 10px;
            border-radius: 6px;
            font-weight: bold;
        }

        .arrow {
            display: inline-block;
            margin: 0 10px;
            font-size: 1.5em;
            color: #667eea;
        }

        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #667eea;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-align: center;
            line-height: 50px;
            cursor: pointer;
            display: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }

        .back-to-top:hover {
            background: #764ba2;
            transform: scale(1.1);
        }

        ul, ol {
            margin-left: 30px;
            margin-top: 10px;
        }

        li {
            margin: 8px 0;
        }

        .highlight {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
        }

        @media print {
            body {
                background: white;
            }
            .container {
                box-shadow: none;
            }
            .back-to-top {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîê Keycloak Integration Guide</h1>
            <p>Complete Documentation for ASP.NET Core - Enterprise Best Practices</p>
        </header>

        <div class="content">
            <div class="toc">
                <h2>üìë Table of Contents</h2>
                <ul>
                    <li><a href="#introduction">Introduction</a></li>
                    <li><a href="#architecture">Architecture Overview</a></li>
                    <li><a href="#keycloak-setup">Keycloak Setup</a></li>
                    <li><a href="#realm-config">Realm Configuration</a></li>
                    <li><a href="#client-config">Client Configuration</a></li>
                    <li><a href="#roles-scopes">Roles & Scopes</a></li>
                    <li><a href="#aspnet-integration">ASP.NET Core Integration</a></li>
                    <li><a href="#best-practices">Best Practices</a></li>
                    <li><a href="#enterprise-patterns">Enterprise Patterns</a></li>
                    <li><a href="#troubleshooting">Troubleshooting</a></li>
                </ul>
            </div>

            <section id="introduction">
                <h2>üìñ Introduction</h2>
                <p>This guide provides a comprehensive walkthrough for integrating Keycloak with ASP.NET Core applications, following enterprise-grade best practices. Keycloak is an open-source identity and access management solution that provides authentication, authorization, and user management capabilities.</p>
                
                <div class="info-box">
                    <strong>üí° Key Principle:</strong> In this architecture, mobile and web clients do NOT directly communicate with Keycloak. All authentication and authorization operations are handled by your ASP.NET Core backend, which acts as a secure intermediary.
                </div>

                <h3>Why This Architecture?</h3>
                <ul>
                    <li><strong>Security:</strong> Client secrets and credentials never leave your backend</li>
                    <li><strong>Control:</strong> Centralized authentication logic and policies</li>
                    <li><strong>Flexibility:</strong> Easy to change identity providers without client changes</li>
                    <li><strong>Auditing:</strong> All authentication events logged in one place</li>
                    <li><strong>Performance:</strong> Token caching and optimization at backend level</li>
                </ul>
            </section>

            <section id="architecture">
                <h2>üèóÔ∏è Architecture Overview</h2>
                
                <div class="architecture-diagram">
                    <div class="architecture-box">Mobile App</div>
                    <span class="arrow">‚Üí</span>
                    <div class="architecture-box">ASP.NET Core API</div>
                    <span class="arrow">‚Üí</span>
                    <div class="architecture-box">Keycloak</div>
                </div>

                <div class="architecture-diagram">
                    <div class="architecture-box">Web App</div>
                    <span class="arrow">‚Üí</span>
                    <div class="architecture-box">ASP.NET Core API</div>
                    <span class="arrow">‚Üí</span>
                    <div class="architecture-box">Keycloak</div>
                </div>

                <h3>Flow Diagram</h3>
                <div class="step">
                    <h4>1. User Login Request</h4>
                    <p>Client (Mobile/Web) ‚Üí POST to <code>/api/auth/login</code> with username/password</p>
                </div>

                <div class="step">
                    <h4>2. Backend Authentication</h4>
                    <p>ASP.NET Core ‚Üí Validates credentials with Keycloak using service account</p>
                </div>

                <div class="step">
                    <h4>3. Token Generation</h4>
                    <p>Keycloak ‚Üí Returns JWT tokens (access + refresh) to backend</p>
                </div>

                <div class="step">
                    <h4>4. Token Response</h4>
                    <p>ASP.NET Core ‚Üí Returns tokens to client (stored securely)</p>
                </div>

                <div class="step">
                    <h4>5. API Requests</h4>
                    <p>Client ‚Üí Sends JWT token in Authorization header ‚Üí ASP.NET Core validates with Keycloak</p>
                </div>

                <div class="warning-box">
                    <strong>‚ö†Ô∏è Important:</strong> Clients never see Keycloak URLs, client secrets, or interact with Keycloak directly. All communication is through your backend API.
                </div>
            </section>

            <section id="keycloak-setup">
                <h2>üîß Keycloak Setup</h2>

                <h3>Prerequisites</h3>
                <ul>
                    <li>Keycloak server installed and running (version 20+ recommended)</li>
                    <li>Access to Keycloak Admin Console</li>
                    <li>Basic understanding of OAuth 2.0 and OpenID Connect</li>
                </ul>

                <h3>Installation Options</h3>
                <div class="step">
                    <h4>Option 1: Docker (Recommended for Development)</h4>
                    <div class="code-block">
<span class="comment"># Run Keycloak with Docker</span>
docker run -d \
  -p 8080:8080 \
  -e KEYCLOAK_ADMIN=admin \
  -e KEYCLOAK_ADMIN_PASSWORD=admin \
  quay.io/keycloak/keycloak:latest \
  start-dev
                    </div>
                </div>

                <div class="step">
                    <h4>Option 2: Standalone Server</h4>
                    <p>Download from <a href="https://www.keycloak.org/downloads" target="_blank">keycloak.org</a> and follow installation guide.</p>
                </div>

                <div class="info-box">
                    <strong>üí° Production Tip:</strong> For production, use PostgreSQL or MySQL database instead of embedded H2, enable HTTPS, and configure proper clustering.
                </div>
            </section>

            <section id="realm-config">
                <h2>üåç Realm Configuration</h2>

                <div class="step">
                    <span class="step-number">1</span>
                    <h3>Create Realm</h3>
                    <ol>
                        <li>Log in to Keycloak Admin Console (usually <code>http://localhost:8080</code>)</li>
                        <li>Click on the realm dropdown (top-left, shows "master" by default)</li>
                        <li>Click <strong>"Create Realm"</strong></li>
                        <li>Enter realm name: <span class="highlight">gps</span> (lowercase as per your requirement)</li>
                        <li>Enable: <strong>Realm enabled</strong> toggle</li>
                        <li>Click <strong>"Create"</strong></li>
                    </ol>

                    <div class="info-box">
                        <strong>What is a Realm?</strong> A realm manages a set of users, credentials, roles, and groups. Each realm is isolated and can have its own authentication and authorization settings. Think of it as a separate tenant.
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">2</span>
                    <h3>Configure Default Group</h3>
                    <p>This ensures every new user is automatically added to a default group.</p>
                    
                    <ol>
                        <li>Navigate to <strong>Groups</strong> in the left menu</li>
                        <li>Click <strong>"Create group"</strong></li>
                        <li>Name: <span class="highlight">default-users</span></li>
                        <li>Click <strong>"Create"</strong></li>
                        <li>Go to <strong>Realm Settings</strong> ‚Üí <strong>User Registration</strong> tab</li>
                        <li>Find <strong>"Default Groups"</strong> section</li>
                        <li>Click <strong>"Add"</strong> and select <code>default-users</code></li>
                        <li>Click <strong>"Save"</strong></li>
                    </ol>

                    <div class="code-block">
<span class="comment">// This means every new user will automatically have:</span>
<span class="comment">// - All roles assigned to "default-users" group</span>
<span class="comment">// - All attributes from the group</span>
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">3</span>
                    <h3>Realm Settings - General</h3>
                    <table>
                        <tr>
                            <th>Setting</th>
                            <th>Value</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td>Realm name</td>
                            <td>gps</td>
                            <td>Display name of the realm</td>
                        </tr>
                        <tr>
                            <td>Enabled</td>
                            <td>ON</td>
                            <td>Realm is active</td>
                        </tr>
                        <tr>
                            <td>User managed access</td>
                            <td>OFF</td>
                            <td>Only enable if using UMA (not needed for basic setup)</td>
                        </tr>
                        <tr>
                            <td>Login with email</td>
                            <td>ON</td>
                            <td>Users can login with email instead of username</td>
                        </tr>
                        <tr>
                            <td>Duplicate emails</td>
                            <td>OFF</td>
                            <td>Prevent multiple users with same email</td>
                        </tr>
                        <tr>
                            <td>Require SSL</td>
                            <td>external</td>
                            <td>Require HTTPS for external requests (production)</td>
                        </tr>
                    </table>
                </div>

                <div class="step">
                    <span class="step-number">4</span>
                    <h3>Realm Settings - Tokens</h3>
                    <p>Configure token expiration and refresh settings:</p>
                    <table>
                        <tr>
                            <th>Setting</th>
                            <th>Recommended Value</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td>Access Token Lifespan</td>
                            <td>5 minutes</td>
                            <td>How long access token is valid</td>
                        </tr>
                        <tr>
                            <td>SSO Session Idle</td>
                            <td>30 minutes</td>
                            <td>Idle timeout for SSO session</td>
                        </tr>
                        <tr>
                            <td>SSO Session Max</td>
                            <td>10 hours</td>
                            <td>Maximum SSO session duration</td>
                        </tr>
                        <tr>
                            <td>Access Token Lifespan For Implicit Flow</td>
                            <td>15 minutes</td>
                            <td>For implicit flow (if used)</td>
                        </tr>
                        <tr>
                            <td>Client login timeout</td>
                            <td>1 minute</td>
                            <td>Timeout for client login</td>
                        </tr>
                    </table>

                    <div class="warning-box">
                        <strong>‚ö†Ô∏è Security Best Practice:</strong> Keep access token lifespan short (5-15 minutes) and use refresh tokens for longer sessions. This minimizes risk if a token is compromised.
                    </div>
                </div>
            </section>

            <section id="client-config">
                <h2>üîë Client Configuration: Public vs Private Clients</h2>

                <div class="step">
                    <span class="step-number">0</span>
                    <h3>Quick Reference: Client Types Summary</h3>
                    <table>
                        <tr>
                            <th>Feature</th>
                            <th>Public Client<br/>(Backend Service)</th>
                            <th>Private Client<br/>(Service Account)</th>
                        </tr>
                        <tr>
                            <td><strong>Example</strong></td>
                            <td>gps-content-api</td>
                            <td>gps-core-host</td>
                        </tr>
                        <tr>
                            <td><strong>Purpose</strong></td>
                            <td>Token validation only</td>
                            <td>Authentication controller</td>
                        </tr>
                        <tr>
                            <td><strong>Client Authentication</strong></td>
                            <td>OFF</td>
                            <td>ON</td>
                        </tr>
                        <tr>
                            <td><strong>Service Account</strong></td>
                            <td>OFF</td>
                            <td>ON</td>
                        </tr>
                        <tr>
                            <td><strong>Direct Access Grants</strong></td>
                            <td>OFF</td>
                            <td>ON</td>
                        </tr>
                        <tr>
                            <td><strong>Client Secret</strong></td>
                            <td>Not needed</td>
                            <td>Required</td>
                        </tr>
                        <tr>
                            <td><strong>Configuration</strong></td>
                            <td>Only Keycloak section</td>
                            <td>Keycloak + KeycloakAdmin</td>
                        </tr>
                        <tr>
                            <td><strong>Client Scope</strong></td>
                            <td>audience-scope (required)</td>
                            <td>audience-scope (required)</td>
                        </tr>
                    </table>
                </div>

                <div class="step">
                    <span class="step-number">1</span>
                    <h3>Understanding Client Types</h3>
                    <p>In a multi-backend architecture, you need to understand the difference between <strong>Public Clients</strong> (for backend services) and <strong>Private Clients</strong> (for your Keycloak wrapper/controller).</p>

                    <div class="success-box">
                        <strong>‚úÖ Public Client (Backend Service - e.g., gps-content-api):</strong>
                        <ul>
                            <li><strong>Purpose:</strong> Token validation only - identifies which API the token is for</li>
                            <li><strong>Access Level:</strong> ZERO - Cannot manage users, cannot get tokens, cannot do anything</li>
                            <li><strong>Client Authentication:</strong> OFF (no client secret)</li>
                            <li><strong>Service Account:</strong> OFF</li>
                            <li><strong>Direct Access Grants:</strong> OFF</li>
                            <li><strong>Configuration Needed:</strong> Only the client ID (for audience validation)</li>
                        </ul>
                    </div>

                    <div class="info-box">
                        <strong>üîê Private Client (Service Account - e.g., gps-core-host):</strong>
                        <ul>
                            <li><strong>Purpose:</strong> Keycloak wrapper/controller - manages authentication flow</li>
                            <li><strong>Access Level:</strong> FULL - Can manage users, groups, roles, sessions</li>
                            <li><strong>Client Authentication:</strong> ON (has client secret)</li>
                            <li><strong>Service Account:</strong> ON (can act on behalf of system)</li>
                            <li><strong>Direct Access Grants:</strong> ON (for login operations)</li>
                            <li><strong>Configuration Needed:</strong> Client ID + Client Secret</li>
                        </ul>
                    </div>

                    <div class="warning-box">
                        <strong>‚ö†Ô∏è Critical Understanding:</strong>
                        <ul>
                            <li>Public clients are <strong>NOT for authentication</strong> - they only validate tokens</li>
                            <li>Each backend service should have its own public client (e.g., gps-content-api, gps-notification-api)</li>
                            <li>Only ONE private client (gps-core-host) is needed for the entire system</li>
                            <li>The private client acts as a proxy - all authentication operations go through it</li>
                        </ul>
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">2</span>
                    <h3>Create Private Client - Service Account (gps-core-host)</h3>
                    <p>This is your <strong>Keycloak wrapper/controller backend</strong> that manages all authentication operations.</p>

                    <ol>
                        <li>Navigate to <strong>Clients</strong> in the left menu</li>
                        <li>Click <strong>"Create client"</strong></li>
                        <li><strong>Client type:</strong> OpenID Connect</li>
                        <li><strong>Client ID:</strong> <span class="highlight">gps-core-host</span></li>
                        <li>Click <strong>"Next"</strong></li>
                    </ol>

                    <h4>Capability Config (CRITICAL SETTINGS):</h4>
                    <table>
                        <tr>
                            <th>Capability</th>
                            <th>Status</th>
                            <th>Why?</th>
                        </tr>
                        <tr>
                            <td><strong>Client authentication</strong></td>
                            <td>‚úÖ ON</td>
                            <td>Required for service accounts. Enables client credentials flow.</td>
                        </tr>
                        <tr>
                            <td><strong>Authorization</strong></td>
                            <td>‚ùå OFF</td>
                            <td>Only needed if using fine-grained authorization (not needed for basic setup)</td>
                        </tr>
                        <tr>
                            <td><strong>Standard flow</strong></td>
                            <td>‚ùå OFF</td>
                            <td>Not needed - clients don't access Keycloak directly</td>
                        </tr>
                        <tr>
                            <td><strong>Direct access grants</strong></td>
                            <td>‚úÖ ON</td>
                            <td>Allows backend to authenticate users with username/password</td>
                        </tr>
                        <tr>
                            <td><strong>Service accounts roles</strong></td>
                            <td>‚úÖ ON</td>
                            <td>Enables service account to have roles and permissions</td>
                        </tr>
                        <tr>
                            <td><strong>OIDC CBC logout</strong></td>
                            <td>‚ùå OFF</td>
                            <td>Not needed for API-based authentication</td>
                        </tr>
                    </table>

                    <div class="info-box">
                        <strong>üí° What is Client Authentication?</strong> When enabled, the client must authenticate itself using a client secret (like a password for the client). This is required for service accounts and secure backend-to-backend communication.
                    </div>

                    <h4>Additional Settings:</h4>
                    <ol>
                        <li>Go to <strong>"Credentials"</strong> tab</li>
                        <li>Copy the <strong>"Client secret"</strong> - you'll need this in your ASP.NET Core appsettings.json</li>
                        <li>Go to <strong>"Service account roles"</strong> tab (we'll configure this in Roles section)</li>
                    </ol>
                </div>

                <div class="step">
                    <span class="step-number">3</span>
                    <h3>Create Public Client for Backend Service (gps-content-api)</h3>
                    <p>This is a <strong>public client with ZERO access</strong> - used only for token validation (audience claim).</p>
                    
                    <div class="danger-box">
                        <strong>üö® Important:</strong> This client has NO permissions. It cannot authenticate, cannot manage users, cannot do anything except appear as an audience in tokens.
                    </div>

                    <ol>
                        <li>Click <strong>"Create client"</strong></li>
                        <li><strong>Client type:</strong> OpenID Connect</li>
                        <li><strong>Client ID:</strong> <span class="highlight">gps-content-api</span></li>
                        <li>Click <strong>"Next"</strong></li>
                    </ol>

                    <h4>Capability Config:</h4>
                    <table>
                        <tr>
                            <th>Capability</th>
                            <th>Status</th>
                            <th>Why?</th>
                        </tr>
                        <tr>
                            <td><strong>Client authentication</strong></td>
                            <td>‚ùå OFF</td>
                            <td>This client only validates tokens, doesn't need to authenticate</td>
                        </tr>
                        <tr>
                            <td><strong>Authorization</strong></td>
                            <td>‚ùå OFF</td>
                            <td>Not needed for basic token validation</td>
                        </tr>
                        <tr>
                            <td><strong>Standard flow</strong></td>
                            <td>‚ùå OFF</td>
                            <td>Clients don't access Keycloak directly</td>
                        </tr>
                        <tr>
                            <td><strong>Direct access grants</strong></td>
                            <td>‚ùå OFF</td>
                            <td>Not needed - authentication handled by backend</td>
                        </tr>
                        <tr>
                            <td><strong>Service accounts roles</strong></td>
                            <td>‚ùå OFF</td>
                            <td>This is not a service account</td>
                        </tr>
                    </table>

                    <h4>Access Settings:</h4>
                    <ol>
                        <li>Go to <strong>"Settings"</strong> tab</li>
                        <li><strong>Access Type:</strong> public (since client authentication is OFF)</li>
                        <li><strong>Valid Redirect URIs:</strong> Leave empty (not used in backend-only flow)</li>
                        <li><strong>Web Origins:</strong> Leave empty</li>
                        <li>Click <strong>"Save"</strong></li>
                    </ol>

                    <div class="info-box">
                        <strong>üí° Why Public Client?</strong> Since this client doesn't authenticate itself (no client secret), it's a public client. It's used <strong>ONLY</strong> to identify which API the token is for (audience claim). Your backend will validate that incoming tokens have <code>"aud": "gps-content-api"</code> in the token.
                    </div>

                    <h4>Backend Configuration for Public Client:</h4>
                    <p>For a backend service using a public client, you only need minimal configuration:</p>
                    <div class="code-block">
<span class="comment">// appsettings.json for gps-content-api backend</span>
{
  <span class="string">"Keycloak"</span>: {
    <span class="string">"KeycloakBaseUrl"</span>: <span class="string">"http://localhost:8080"</span>,
    <span class="string">"Realm"</span>: <span class="string">"gps"</span>,
    <span class="string">"Audience"</span>: <span class="string">"gps-content-api"</span>, <span class="comment">// Must match client ID</span>
    <span class="string">"Issuer"</span>: <span class="string">"http://localhost:8080/realms/gps"</span>,
    <span class="string">"RequireHttpsMetadata"</span>: <span class="keyword">false</span>
  }
  <span class="comment">// NO KeycloakAdmin section needed - this backend doesn't manage users</span>
}
                    </div>

                    <div class="info-box">
                        <strong>üìã Configuration Summary for Public Client Backend:</strong>
                        <ul>
                            <li>‚úÖ Only <code>Keycloak</code> section needed</li>
                            <li>‚úÖ <code>Audience</code> must match the client ID exactly</li>
                            <li>‚úÖ No client secret needed (public client)</li>
                            <li>‚úÖ No admin operations - only token validation</li>
                        </ul>
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">4</span>
                    <h3>Client Scopes Configuration - Adding Audience to Tokens</h3>
                    <p>Client scopes control what claims (information) are included in tokens. For public clients, you need to add the <strong>audience scope</strong> so tokens include the client ID as an audience claim.</p>

                    <div class="warning-box">
                        <strong>‚ö†Ô∏è Why This Matters:</strong> Without the audience scope, tokens won't include the <code>aud</code> claim, and your backend won't be able to validate that the token is intended for it.
                    </div>

                    <h4>Create Audience Scope:</h4>
                    <ol>
                        <li>Navigate to <strong>"Client scopes"</strong> in the left menu</li>
                        <li>Click <strong>"Create client scope"</strong></li>
                        <li><strong>Name:</strong> <span class="highlight">audience-scope</span></li>
                        <li><strong>Protocol:</strong> openid-connect</li>
                        <li>Click <strong>"Save"</strong></li>
                    </ol>

                    <h4>Add Audience Mappers:</h4>
                    <ol>
                        <li>In the <code>audience-scope</code> you just created, go to <strong>"Mappers"</strong> tab</li>
                        <li>Click <strong>"Add mapper"</strong> ‚Üí <strong>"By configuration"</strong></li>
                        <li>Select <strong>"Audience"</strong></li>
                        <li>Click <strong>"Add"</strong></li>
                    </ol>

                    <h4>Configure First Audience Mapper:</h4>
                    <table>
                        <tr>
                            <th>Field</th>
                            <th>Value</th>
                        </tr>
                        <tr>
                            <td>Name</td>
                            <td>gps-content-api-audience</td>
                        </tr>
                        <tr>
                            <td>Included Client Audience</td>
                            <td>gps-content-api</td>
                        </tr>
                        <tr>
                            <td>Add to access token</td>
                            <td>ON</td>
                        </tr>
                        <tr>
                            <td>Add to ID token</td>
                            <td>OFF</td>
                        </tr>
                    </table>
                    <p>Click <strong>"Save"</strong></p>

                    <h4>Configure Second Audience Mapper:</h4>
                    <ol>
                        <li>Click <strong>"Add mapper"</strong> ‚Üí <strong>"By configuration"</strong> ‚Üí <strong>"Audience"</strong> again</li>
                        <li>Configure:
                            <table>
                                <tr>
                                    <th>Field</th>
                                    <th>Value</th>
                                </tr>
                                <tr>
                                    <td>Name</td>
                                    <td>gps-core-host-audience</td>
                                </tr>
                                <tr>
                                    <td>Included Client Audience</td>
                                    <td>gps-core-host</td>
                                </tr>
                                <tr>
                                    <td>Add to access token</td>
                                    <td>ON</td>
                                </tr>
                            </table>
                        </li>
                        <li>Click <strong>"Save"</strong></li>
                    </ol>

                    <h4>Assign Scope to Clients (CRITICAL STEP):</h4>
                    <p>You must assign the <code>audience-scope</code> to each public client so tokens include the correct audience claim.</p>
                    
                    <h5>For Public Client (gps-content-api):</h5>
                    <ol>
                        <li>Go to <strong>"Clients"</strong> ‚Üí Select <code>gps-content-api</code></li>
                        <li>Go to <strong>"Client scopes"</strong> tab</li>
                        <li>Under <strong>"Default Client Scopes"</strong>, click <strong>"Add client scope"</strong></li>
                        <li>Select <code>audience-scope</code> and click <strong>"Add"</strong></li>
                        <li>Verify it appears in the <strong>"Default Client Scopes"</strong> list</li>
                    </ol>

                    <h5>For Private Client (gps-core-host):</h5>
                    <ol>
                        <li>Go to <strong>"Clients"</strong> ‚Üí Select <code>gps-core-host</code></li>
                        <li>Go to <strong>"Client scopes"</strong> tab</li>
                        <li>Under <strong>"Default Client Scopes"</strong>, click <strong>"Add client scope"</strong></li>
                        <li>Select <code>audience-scope</code> and click <strong>"Add"</strong></li>
                    </ol>

                    <div class="info-box">
                        <strong>üí° What is Audience?</strong> The audience (aud) claim in a JWT token identifies who the token is intended for. This prevents token reuse across different APIs. When your API validates a token, it checks that the audience matches its client ID.
                    </div>

                    <div class="code-block">
<span class="comment">// Example token with audience claim:</span>
{
  <span class="string">"sub"</span>: <span class="string">"user-id"</span>,
  <span class="string">"aud"</span>: <span class="string">"gps-content-api"</span>, <span class="comment">// This is added by the audience-scope</span>
  <span class="string">"iss"</span>: <span class="string">"http://localhost:8080/realms/gps"</span>,
  <span class="string">"exp"</span>: 1234567890
}
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">5</span>
                    <h3>Backend Configuration Summary</h3>
                    
                    <h4>Configuration for Public Client Backend (e.g., gps-content-api):</h4>
                    <div class="code-block">
<span class="comment">// appsettings.json - Minimal configuration for token validation only</span>
{
  <span class="string">"Keycloak"</span>: {
    <span class="string">"KeycloakBaseUrl"</span>: <span class="string">"http://localhost:8080"</span>,
    <span class="string">"Realm"</span>: <span class="string">"gps"</span>,
    <span class="string">"Audience"</span>: <span class="string">"gps-content-api"</span>, <span class="comment">// Must match client ID</span>
    <span class="string">"Issuer"</span>: <span class="string">"http://localhost:8080/realms/gps"</span>,
    <span class="string">"RequireHttpsMetadata"</span>: <span class="keyword">false</span>, <span class="comment">// true in production</span>
    <span class="string">"RolesClaimsTransformation"</span>: <span class="string">"Both"</span>
  }
  <span class="comment">// NO KeycloakAdmin section - this backend doesn't manage users</span>
}
                    </div>

                    <h4>Configuration for Private Client Backend (gps-core-host):</h4>
                    <div class="code-block">
<span class="comment">// appsettings.json - Full configuration for authentication controller</span>
{
  <span class="string">"Keycloak"</span>: {
    <span class="string">"KeycloakBaseUrl"</span>: <span class="string">"http://localhost:8080"</span>,
    <span class="string">"Realm"</span>: <span class="string">"gps"</span>,
    <span class="string">"Audience"</span>: <span class="string">"gps-core-host"</span>,
    <span class="string">"Issuer"</span>: <span class="string">"http://localhost:8080/realms/gps"</span>,
    <span class="string">"RequireHttpsMetadata"</span>: <span class="keyword">false</span>
  },
  <span class="string">"KeycloakAdmin"</span>: {
    <span class="string">"KeycloakBaseUrl"</span>: <span class="string">"http://localhost:8080"</span>,
    <span class="string">"Realm"</span>: <span class="string">"gps"</span>,
    <span class="string">"Credentials"</span>: {
      <span class="string">"ClientId"</span>: <span class="string">"gps-core-host"</span>, <span class="comment">// Private client ID</span>
      <span class="string">"ClientSecret"</span>: <span class="string">"YOUR_SERVICE_ACCOUNT_SECRET_HERE"</span>
    }
  }
}
                    </div>

                    <div class="info-box">
                        <strong>üìã Configuration Checklist:</strong>
                        <ul>
                            <li><strong>Public Client Backend:</strong> Only <code>Keycloak</code> section, no secret needed</li>
                            <li><strong>Private Client Backend:</strong> Both <code>Keycloak</code> and <code>KeycloakAdmin</code> sections, secret required</li>
                            <li><strong>Audience:</strong> Must match the client ID exactly in both cases</li>
                            <li><strong>Client Scope:</strong> Must assign <code>audience-scope</code> to both clients in Keycloak</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section id="roles-scopes">
                <h2>üë• Roles & Scopes Configuration</h2>

                <div class="step">
                    <span class="step-number">1</span>
                    <h3>Realm Roles (Global Roles)</h3>
                    <p>These roles apply across the entire realm and are stored in <code>realm_access.roles</code> in the token.</p>

                    <h4>Create Realm Roles:</h4>
                    <ol>
                        <li>Navigate to <strong>"Realm roles"</strong> in the left menu</li>
                        <li>Click <strong>"Create role"</strong></li>
                        <li>Create the following roles:
                            <ul>
                                <li><strong>Admin</strong> - Full system access</li>
                                <li><strong>Teacher</strong> - Teacher-specific permissions</li>
                                <li><strong>Parent</strong> - Parent-specific permissions</li>
                                <li><strong>Student</strong> - Student-specific permissions</li>
                            </ul>
                        </li>
                    </ol>

                    <div class="code-block">
<span class="comment">// These roles will appear in the JWT token as:</span>
{
  <span class="string">"realm_access"</span>: {
    <span class="string">"roles"</span>: [<span class="string">"Admin"</span>, <span class="string">"Teacher"</span>]
  }
}
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">2</span>
                    <h3>Client Roles (Scoped Roles)</h3>
                    <p>These roles are specific to a client and appear in <code>resource_access.{clientId}.roles</code>.</p>

                    <h4>Create Client Roles for gps-content-api:</h4>
                    <ol>
                        <li>Go to <strong>"Clients"</strong> ‚Üí Select <code>gps-content-api</code></li>
                        <li>Go to <strong>"Roles"</strong> tab</li>
                        <li>Click <strong>"Create role"</strong></li>
                        <li>Create roles:
                            <ul>
                                <li><strong>content.read</strong> - Read content</li>
                                <li><strong>content.write</strong> - Write/create content</li>
                                <li><strong>content.delete</strong> - Delete content</li>
                            </ul>
                        </li>
                    </ol>

                    <h4>Create Client Roles for gps-core-host:</h4>
                    <ol>
                        <li>Go to <strong>"Clients"</strong> ‚Üí Select <code>gps-core-host</code></li>
                        <li>Go to <strong>"Roles"</strong> tab</li>
                        <li>Create roles:
                            <ul>
                                <li><strong>core.read</strong> - Read core data</li>
                                <li><strong>core.write</strong> - Write core data</li>
                                <li><strong>core.admin</strong> - Core administration</li>
                            </ul>
                        </li>
                    </ol>

                    <div class="code-block">
<span class="comment">// These roles will appear in the JWT token as:</span>
{
  <span class="string">"resource_access"</span>: {
    <span class="string">"gps-content-api"</span>: {
      <span class="string">"roles"</span>: [<span class="string">"content.read"</span>, <span class="string">"content.write"</span>]
    },
    <span class="string">"gps-core-host"</span>: {
      <span class="string">"roles"</span>: [<span class="string">"core.read"</span>]
    }
  }
}
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">3</span>
                    <h3>Assign Service Account Roles</h3>
                    <p>Give your backend service (gps-core-host) the ability to manage users.</p>

                    <ol>
                        <li>Go to <strong>"Clients"</strong> ‚Üí Select <code>gps-core-host</code></li>
                        <li>Go to <strong>"Service account roles"</strong> tab</li>
                        <li>Click <strong>"Assign role"</strong></li>
                        <li>Filter by <strong>"Filter by clients"</strong></li>
                        <li>Select <strong>"realm-management"</strong> client</li>
                        <li>Assign these roles:
                            <ul>
                                <li><strong>manage-users</strong> - Create, update, delete users</li>
                                <li><strong>query-users</strong> - Search and query users</li>
                                <li><strong>view-users</strong> - View user details</li>
                                <li><strong>manage-clients</strong> - Manage clients (if needed)</li>
                                <li><strong>view-realm</strong> - View realm information</li>
                                <li><strong>manage-realm</strong> - Full realm management (use carefully)</li>
                            </ul>
                        </li>
                        <li>Click <strong>"Assign"</strong></li>
                    </ol>

                    <div class="warning-box">
                        <strong>‚ö†Ô∏è Principle of Least Privilege:</strong> Only assign the minimum roles needed. For most applications, <code>manage-users</code>, <code>query-users</code>, and <code>view-users</code> are sufficient.
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">4</span>
                    <h3>Assign Roles to Users</h3>
                    <p>How to assign roles to users (can be done via API or Admin Console).</p>

                    <h4>Via Admin Console:</h4>
                    <ol>
                        <li>Go to <strong>"Users"</strong> ‚Üí Select a user</li>
                        <li>Go to <strong>"Role mapping"</strong> tab</li>
                        <li>Click <strong>"Assign role"</strong></li>
                        <li>Select <strong>"Realm roles"</strong> or <strong>"Client roles"</strong></li>
                        <li>Select roles and click <strong>"Assign"</strong></li>
                    </ol>

                    <div class="info-box">
                        <strong>üí° Best Practice:</strong> Assign roles to groups instead of individual users. Then assign users to groups. This makes role management much easier.
                    </div>
                </div>
            </section>

            <section id="aspnet-integration">
                <h2>üíª ASP.NET Core Integration</h2>

                <div class="step">
                    <span class="step-number">1</span>
                    <h3>Install Required NuGet Packages</h3>
                    <p>Install the LowCodeHub Keycloak packages:</p>
                    
                    <div class="code-block">
<span class="comment"># Install via Package Manager Console</span>
Install-Package LowCodeHub.Keycloak
Install-Package LowCodeHub.Keycloak.Authentication.JwtBearer
                    </div>

                    <div class="code-block">
<span class="comment"># Or via .NET CLI</span>
dotnet add package LowCodeHub.Keycloak
dotnet add package LowCodeHub.Keycloak.Authentication.JwtBearer
                    </div>

                    <div class="info-box">
                        <strong>üí° Package Information:</strong>
                        <ul>
                            <li><strong>LowCodeHub.Keycloak</strong> - Comprehensive Keycloak Admin API client and user authentication client (with built-in cookie support)</li>
                            <li><strong>LowCodeHub.Keycloak.Authentication.JwtBearer</strong> - JWT Bearer authentication with Keycloak integration and authorization policy extensions</li>
                        </ul>
                    </div>

                    <div class="success-box">
                        <strong>‚úÖ All Features Available:</strong> The packages now include IConfiguration support and authorization extensions. See below for usage examples.
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">2</span>
                    <h3>Configure appsettings.json</h3>
                    <p>Configure Keycloak settings in your <code>appsettings.json</code> file. The packages now support both standard property names and Keycloak-style property names:</p>
                    
                    <h4>Option 1: Using Standard Property Names (Recommended)</h4>
                    <div class="code-block">
{
  <span class="string">"Keycloak"</span>: {
    <span class="string">"KeycloakBaseUrl"</span>: <span class="string">"http://localhost:8080"</span>,
    <span class="string">"Realm"</span>: <span class="string">"gps"</span>,
    <span class="string">"Audience"</span>: <span class="string">"gps-content-api"</span>,
    <span class="string">"Issuer"</span>: <span class="string">"http://localhost:8080/realms/gps"</span>,
    <span class="string">"RequireHttpsMetadata"</span>: <span class="keyword">false</span>,
    <span class="string">"RoleClaimType"</span>: <span class="string">"role"</span>,
    <span class="string">"NameClaimType"</span>: <span class="string">"name"</span>,
    <span class="string">"RolesClaimsTransformation"</span>: <span class="string">"Both"</span>
  },
  <span class="string">"KeycloakAdmin"</span>: {
    <span class="string">"KeycloakBaseUrl"</span>: <span class="string">"http://localhost:8080"</span>,
    <span class="string">"Realm"</span>: <span class="string">"gps"</span>,
    <span class="string">"Credentials"</span>: {
      <span class="string">"ClientId"</span>: <span class="string">"gps-core-host"</span>,
      <span class="string">"ClientSecret"</span>: <span class="string">"YOUR_SERVICE_ACCOUNT_SECRET_HERE"</span>
    },
    <span class="string">"CookieOptions"</span>: {
      <span class="string">"Enabled"</span>: <span class="keyword">true</span>,
      <span class="string">"HttpOnly"</span>: <span class="keyword">true</span>,
      <span class="string">"Secure"</span>: <span class="keyword">false</span>, <span class="comment">// true in production</span>
      <span class="string">"SameSite"</span>: <span class="string">"Strict"</span>,
      <span class="string">"AutoSetCookiesOnLogin"</span>: <span class="keyword">true</span>,
      <span class="string">"AutoClearCookiesOnLogout"</span>: <span class="keyword">true</span>,
      <span class="string">"InvalidateKeycloakSessionsOnLogout"</span>: <span class="keyword">true</span>
    }
  }
}
                    </div>

                    <h4>Option 2: Using Keycloak-Style Property Names (Also Supported)</h4>
                    <div class="code-block">
{
  <span class="string">"Keycloak"</span>: {
    <span class="string">"realm"</span>: <span class="string">"gps"</span>,
    <span class="string">"auth-server-url"</span>: <span class="string">"http://localhost:8080/"</span>,
    <span class="string">"resource"</span>: <span class="string">"gps-content-api"</span>,
    <span class="string">"ssl-required"</span>: <span class="string">"none"</span>
  },
  <span class="string">"KeycloakAdmin"</span>: {
    <span class="string">"realm"</span>: <span class="string">"gps"</span>,
    <span class="string">"auth-server-url"</span>: <span class="string">"http://localhost:8080/"</span>,
    <span class="string">"resource"</span>: <span class="string">"gps-core-host"</span>,
    <span class="string">"credentials"</span>: {
      <span class="string">"secret"</span>: <span class="string">"YOUR_SERVICE_ACCOUNT_SECRET_HERE"</span>
    }
  }
}
                    </div>

                    <div class="info-box">
                        <strong>üí° Configuration Notes:</strong>
                        <ul>
                            <li><strong>Keycloak</strong> section: Used for JWT Bearer authentication</li>
                            <li><strong>KeycloakAdmin</strong> section: Used for Admin API client (user management)</li>
                            <li><strong>KeycloakBaseUrl</strong> or <strong>auth-server-url</strong>: Base URL of Keycloak server</li>
                            <li><strong>Realm</strong>: The realm name (e.g., "gps")</li>
                            <li><strong>Audience</strong> or <strong>resource</strong>: The client ID for token validation</li>
                            <li><strong>Issuer</strong>: Full issuer URL (auto-generated if not provided: {KeycloakBaseUrl}/realms/{Realm})</li>
                            <li><strong>Property Name Mapping</strong>: The packages support both standard names (KeycloakBaseUrl) and Keycloak-style names (auth-server-url)</li>
                        </ul>
                    </div>

                    <div class="warning-box">
                        <strong>‚ö†Ô∏è Security:</strong> Never commit secrets to source control. Use User Secrets for development and Azure Key Vault / AWS Secrets Manager for production.
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">3</span>
                    <h3>Program.cs Configuration</h3>
                    <p>Configure Keycloak services in <code>Program.cs</code>. The packages now support both IConfiguration and Action-based configuration:</p>
                    
                    <h4>Option 1: Using IConfiguration (Recommended - New Feature!)</h4>
                    <div class="code-block">
<span class="keyword">using</span> LowCodeHub.Keycloak.Client.Extensions;
<span class="keyword">using</span> LowCodeHub.Keycloak.Authentication.JwtBearer.Extensions;

<span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);

<span class="comment">// Add services</span>
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

<span class="comment">// Configure Keycloak JWT Bearer Authentication using IConfiguration</span>
<span class="comment">// Automatically binds from appsettings.json "Keycloak" section</span>
builder.Services.AddKeycloakJwtBearerAuthentication(builder.Configuration, <span class="string">"Keycloak"</span>);

<span class="comment">// Configure Keycloak Admin Client using IConfiguration</span>
<span class="comment">// Automatically binds from appsettings.json "KeycloakAdmin" section</span>
builder.Services.AddKeycloakClient(builder.Configuration, <span class="string">"KeycloakAdmin"</span>);

<span class="comment">// Add HTTP Client Factory for additional Keycloak operations</span>
builder.Services.AddHttpClient();

<span class="comment">// Configure Authorization Policies using LowCodeHub.Keycloak.Authentication.JwtBearer extensions</span>
builder.Services.AddAuthorization(options =&gt;
{
    <span class="comment">// Policy for content.write client role - using RequireResourceRoles extension</span>
    options.AddPolicy(<span class="string">"RequireContentWrite"</span>, policy =&gt;
    {
        policy.RequireResourceRoles(<span class="string">"gps-content-api"</span>, <span class="string">"content.write"</span>);
    });

    <span class="comment">// Policy for content.read client role</span>
    options.AddPolicy(<span class="string">"RequireContentRead"</span>, policy =&gt;
    {
        policy.RequireResourceRoles(<span class="string">"gps-content-api"</span>, <span class="string">"content.read"</span>);
    });

    <span class="comment">// Policy for Admin realm role - using RequireRealmRoles extension</span>
    options.AddPolicy(<span class="string">"RequireAdmin"</span>, policy =&gt;
    {
        policy.RequireRealmRoles(<span class="string">"Admin"</span>);
    });

    <span class="comment">// Combined policy example</span>
    options.AddPolicy(<span class="string">"AdminAndUser"</span>, policy =&gt;
    {
        policy.RequireRealmRoles(<span class="string">"User"</span>);
        policy.RequireResourceRoles(<span class="string">"gps-content-api"</span>, <span class="string">"Admin"</span>);
    });
});

    <span class="comment">// Authorization extensions are now in LowCodeHub.Keycloak.Authentication.JwtBearer package</span>
    <span class="comment">// No additional service registration needed - just use RequireRealmRoles() and RequireResourceRoles()</span>
                    </div>

                    <h4>Option 2: Using Action-Based Configuration (Still Supported)</h4>
                    <div class="code-block">
<span class="comment">// Manual configuration using Action delegate</span>
builder.Services.AddKeycloakJwtBearerAuthentication(options =&gt;
{
    options.KeycloakBaseUrl = <span class="string">"http://localhost:8080"</span>;
    options.Realm = <span class="string">"gps"</span>;
    options.Audience = <span class="string">"gps-content-api"</span>;
    options.Issuer = <span class="string">"http://localhost:8080/realms/gps"</span>;
    options.RequireHttpsMetadata = <span class="keyword">false</span>;
    options.RoleClaimType = <span class="string">"role"</span>;
    options.NameClaimType = <span class="string">"name"</span>;
    options.RolesClaimsTransformation = RolesClaimsTransformation.Both;
    options.JwksOption = <span class="keyword">new</span> JwksOptions
    {
        BackchannelHttpHandler = <span class="keyword">new</span> HttpClientHandler()
    };
});

builder.Services.AddKeycloakClient(options =&gt;
{
    options.KeycloakBaseUrl = <span class="string">"http://localhost:8080"</span>;
    options.Realm = <span class="string">"gps"</span>;
    options.Credentials = <span class="keyword">new</span> KeycloakCredentials
    {
        ClientId = <span class="string">"gps-core-host"</span>,
        ClientSecret = <span class="string">"YOUR_SERVICE_ACCOUNT_SECRET_HERE"</span>
    };
});
                    </div>

<span class="keyword">var</span> app = builder.Build();

<span class="comment">// Configure the HTTP request pipeline</span>
<span class="keyword">if</span> (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthentication(); <span class="comment">// Must come before UseAuthorization</span>
app.UseAuthorization();

<span class="comment">// Map Minimal API endpoints (defined below)</span>
app.MapAuthEndpoints();
app.MapContentEndpoints();
app.MapUserEndpoints();

app.Run();
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">4</span>
                    <h3>Configure Cookie Support (Optional but Recommended for Web Apps)</h3>
                    <p>Enable built-in cookie support in your <code>appsettings.json</code> for automatic cookie management:</p>
                    
                    <div class="code-block">
<span class="comment">// appsettings.json - Add CookieOptions to KeycloakAdmin section</span>
{
  <span class="string">"KeycloakAdmin"</span>: {
    <span class="string">"KeycloakBaseUrl"</span>: <span class="string">"http://localhost:8080"</span>,
    <span class="string">"Realm"</span>: <span class="string">"gps"</span>,
    <span class="string">"Credentials"</span>: {
      <span class="string">"ClientId"</span>: <span class="string">"gps-core-host"</span>,
      <span class="string">"ClientSecret"</span>: <span class="string">"YOUR_SECRET"</span>
    },
    <span class="string">"CookieOptions"</span>: {
      <span class="string">"Enabled"</span>: <span class="keyword">true</span>,
      <span class="string">"HttpOnly"</span>: <span class="keyword">true</span>,
      <span class="string">"Secure"</span>: <span class="keyword">false</span>, <span class="comment">// true in production</span>
      <span class="string">"SameSite"</span>: <span class="string">"Strict"</span>,
      <span class="string">"AutoSetCookiesOnLogin"</span>: <span class="keyword">true</span>,
      <span class="string">"AutoClearCookiesOnLogout"</span>: <span class="keyword">true</span>,
      <span class="string">"InvalidateKeycloakSessionsOnLogout"</span>: <span class="keyword">true</span>
    }
  }
}
                    </div>

                    <div class="info-box">
                        <strong>üí° Built-in Cookie Support:</strong> When enabled, cookies are automatically set on login and cleared on logout. No manual cookie management needed in your Minimal API endpoints!
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">5</span>
                    <h3>Create Authentication Endpoints (Minimal APIs)</h3>
                    <p>These Minimal API endpoints handle login, registration, token refresh, and logout - all without exposing Keycloak to clients. With built-in cookie support, cookie management is <strong>completely transparent</strong> - just use <code>LoginWithCookiesAsync</code> and <code>LogoutWithCookiesAsync</code>.</p>
                    
                    <div class="info-box">
                        <strong>üí° Features Included:</strong>
                        <ul>
                            <li>Login with optional returnUrl support</li>
                            <li>User registration</li>
                            <li>Token refresh</li>
                            <li>Logout (single session and all sessions)</li>
                            <li>ReturnUrl handling for web app redirects</li>
                        </ul>
                    </div>

                    <h4>Create AuthEndpoints.cs Extension File</h4>
                    <div class="code-block">
<span class="keyword">using</span> LowCodeHub.Keycloak.Client.Clients;
<span class="keyword">using</span> LowCodeHub.Keycloak.Client.Models;
<span class="keyword">using</span> System.Security.Claims;

<span class="keyword">namespace</span> YourApp.Endpoints;

<span class="keyword">public static class</span> <span class="type">AuthEndpoints</span>
{
    <span class="keyword">public static</span> <span class="type">WebApplication</span> <span class="function">MapAuthEndpoints</span>(<span class="keyword">this</span> <span class="type">WebApplication</span> app)
    {
        <span class="keyword">var</span> group = app.MapGroup(<span class="string">"api/auth"</span>).WithTags(<span class="string">"Authentication"</span>);

        <span class="comment">// POST: api/auth/login</span>
        <span class="comment">// Built-in cookie support - cookies are automatically set if enabled in configuration</span>
        group.MapPost(<span class="string">"login"</span>, <span class="keyword">async</span> (
            <span class="type">LoginApiRequest</span> request,
            <span class="type">HttpContext</span> httpContext,
            <span class="type">IKeycloakUserClient</span> keycloakUserClient) =&gt;
        {
            <span class="keyword">try</span>
            {
                <span class="comment">// Use LoginWithCookiesAsync - automatically handles cookies if enabled</span>
                <span class="keyword">var</span> loginRequest = <span class="keyword">new</span> <span class="type">LoginRequest</span>
                {
                    Username = request.Username,
                    Password = request.Password
                };

                <span class="keyword">var</span> keycloakToken = <span class="keyword">await</span> keycloakUserClient.LoginWithCookiesAsync(loginRequest, httpContext);
                
                <span class="comment">// Map to TokenResponse DTO</span>
                <span class="comment">// Note: If cookies are enabled, tokens are in cookies, not in response</span>
                <span class="keyword">var</span> tokenResponse = <span class="keyword">new</span> <span class="type">TokenResponse</span>
                {
                    AccessToken = keycloakToken.AccessToken, <span class="comment">// May be null if cookies enabled</span>
                    RefreshToken = keycloakToken.RefreshToken, <span class="comment">// May be null if cookies enabled</span>
                    ExpiresIn = keycloakToken.ExpiresIn,
                    TokenType = keycloakToken.TokenType ?? <span class="string">"Bearer"</span>,
                    ReturnUrl = request.ReturnUrl
                };
                
                <span class="keyword">return</span> <span class="type">Results</span>.Ok(tokenResponse);
            }
            <span class="keyword">catch</span> (<span class="type">Exception</span> ex)
            {
                <span class="keyword">return</span> <span class="type">Results</span>.Problem(
                    detail: ex.Message, 
                    statusCode: 500);
            }
        })
        .WithName(<span class="string">"Login"</span>)
        .WithSummary(<span class="string">"Authenticate user and get tokens"</span>)
        .Accepts&lt;<span class="type">LoginApiRequest</span>&gt;(<span class="string">"application/json"</span>)
        .Produces&lt;<span class="type">TokenResponse</span>&gt;(200)
        .Produces(401);

        <span class="comment">// POST: api/auth/register</span>
        group.MapPost(<span class="string">"register"</span>, <span class="keyword">async</span> (
            <span class="type">RegisterRequest</span> request,
            <span class="type">IKeycloakAdminClient</span> keycloakAdminClient) =&gt;
        {
            <span class="keyword">try</span>
            {
                <span class="comment">// Use LowCodeHub.Keycloak admin client to create user</span>
                <span class="keyword">var</span> createUserRequest = <span class="keyword">new</span> <span class="type">CreateUserRequest</span>
                {
                    Username = request.Username,
                    Email = request.Email,
                    EmailVerified = <span class="keyword">false</span>,
                    Enabled = <span class="keyword">true</span>,
                    Credentials = <span class="keyword">new</span> <span class="type">List</span>&lt;<span class="type">UserCredential</span>&gt;
                    {
                        <span class="keyword">new</span> <span class="type">UserCredential</span>
                        {
                            Type = <span class="string">"password"</span>,
                            Value = request.Password,
                            Temporary = <span class="keyword">false</span>
                        }
                    }
                };

                <span class="keyword">var</span> userId = <span class="keyword">await</span> keycloakAdminClient.CreateUserAsync(createUserRequest);
                
                <span class="keyword">return</span> <span class="type">Results</span>.Ok(<span class="keyword">new</span> 
                { 
                    userId, 
                    message = <span class="string">"User created successfully"</span> 
                });
            }
            <span class="keyword">catch</span> (<span class="type">Exception</span> ex)
            {
                <span class="keyword">return</span> <span class="type">Results</span>.Problem(
                    detail: ex.Message, 
                    statusCode: 500);
            }
        })
        .WithName(<span class="string">"Register"</span>)
        .WithSummary(<span class="string">"Register a new user"</span>)
        .Accepts&lt;<span class="type">RegisterRequest</span>&gt;(<span class="string">"application/json"</span>)
        .Produces(200);

        <span class="comment">// POST: api/auth/refresh</span>
        group.MapPost(<span class="string">"refresh"</span>, <span class="keyword">async</span> (
            <span class="type">RefreshRequest</span> request,
            <span class="type">IKeycloakUserClient</span> keycloakUserClient) =&gt;
        {
            <span class="keyword">try</span>
            {
                <span class="comment">// Use LowCodeHub.Keycloak user client for token refresh</span>
                <span class="keyword">var</span> keycloakToken = <span class="keyword">await</span> keycloakUserClient.RefreshTokenAsync(request.RefreshToken);
                
                <span class="comment">// Map to TokenResponse DTO</span>
                <span class="keyword">var</span> tokenResponse = <span class="keyword">new</span> <span class="type">TokenResponse</span>
                {
                    AccessToken = keycloakToken.AccessToken,
                    RefreshToken = keycloakToken.RefreshToken,
                    ExpiresIn = keycloakToken.ExpiresIn,
                    TokenType = keycloakToken.TokenType ?? <span class="string">"Bearer"</span>
                };
                
                <span class="keyword">return</span> <span class="type">Results</span>.Ok(tokenResponse);
            }
            <span class="keyword">catch</span> (<span class="type">Exception</span> ex)
            {
                <span class="keyword">return</span> <span class="type">Results</span>.Problem(
                    detail: ex.Message, 
                    statusCode: 500);
            }
        })
        .WithName(<span class="string">"RefreshToken"</span>)
        .WithSummary(<span class="string">"Refresh access token"</span>)
        .Accepts&lt;<span class="type">RefreshRequest</span>&gt;(<span class="string">"application/json"</span>)
        .Produces&lt;<span class="type">TokenResponse</span>&gt;(200)
        .Produces(401);

        <span class="comment">// POST: api/auth/logout</span>
        <span class="comment">// Built-in cookie support - automatically clears cookies and invalidates Keycloak sessions</span>
        group.MapPost(<span class="string">"logout"</span>, <span class="keyword">async</span> (
            <span class="type">HttpContext</span> httpContext,
            <span class="type">IKeycloakUserClient</span> keycloakUserClient,
            <span class="type">IKeycloakAdminClient</span>? keycloakAdminClient) =&gt;
        {
            <span class="keyword">try</span>
            {
                <span class="comment">// Use LogoutWithCookiesAsync - automatically handles cookies and Keycloak sessions</span>
                <span class="keyword">await</span> keycloakUserClient.LogoutWithCookiesAsync(httpContext, keycloakAdminClient, invalidateAllSessions: <span class="keyword">true</span>);

                <span class="keyword">return</span> <span class="type">Results</span>.Ok(<span class="keyword">new</span> { message = <span class="string">"Logged out successfully"</span> });
            }
            <span class="keyword">catch</span> (<span class="type">Exception</span> ex)
            {
                <span class="keyword">return</span> <span class="type">Results</span>.Problem(
                    detail: ex.Message, 
                    statusCode: 500);
            }
        })
        .RequireAuthorization()
        .WithName(<span class="string">"Logout"</span>)
        .WithSummary(<span class="string">"Logout user and invalidate session"</span>)
        .Produces(200)
        .Produces(401);

        <span class="comment">// POST: api/auth/logout-all-sessions</span>
        <span class="comment">// Logout from all sessions - uses built-in cookie support</span>
        group.MapPost(<span class="string">"logout-all-sessions"</span>, <span class="keyword">async</span> (
            <span class="type">HttpContext</span> httpContext,
            <span class="type">IKeycloakUserClient</span> keycloakUserClient,
            <span class="type">IKeycloakAdminClient</span> keycloakAdminClient) =&gt;
        {
            <span class="keyword">try</span>
            {
                <span class="comment">// Use LogoutWithCookiesAsync with admin client - invalidates all sessions</span>
                <span class="keyword">await</span> keycloakUserClient.LogoutWithCookiesAsync(httpContext, keycloakAdminClient, invalidateAllSessions: <span class="keyword">true</span>);
                
                <span class="keyword">return</span> <span class="type">Results</span>.Ok(<span class="keyword">new</span> 
                { 
                    message = <span class="string">"Logged out from all sessions"</span> 
                });
            }
            <span class="keyword">catch</span> (<span class="type">Exception</span> ex)
            {
                <span class="keyword">return</span> <span class="type">Results</span>.Problem(
                    detail: ex.Message, 
                    statusCode: 500);
            }
        })
        .RequireAuthorization()
        .WithName(<span class="string">"LogoutAllSessions"</span>)
        .WithSummary(<span class="string">"Logout user from all devices and sessions"</span>)
        .Produces(200)
        .Produces(401);

        <span class="keyword">return</span> app;
    }
}

<span class="comment">// API DTOs (wrapper around LowCodeHub.Keycloak models)</span>
<span class="keyword">public class</span> <span class="type">LoginApiRequest</span>
{
    <span class="keyword">public string</span> Username { <span class="keyword">get</span>; <span class="keyword">set</span>; }
    <span class="keyword">public string</span> Password { <span class="keyword">get</span>; <span class="keyword">set</span>; }
    <span class="comment">// Optional: For web apps that need to redirect after login</span>
    <span class="keyword">public string</span>? ReturnUrl { <span class="keyword">get</span>; <span class="keyword">set</span>; }
}

<span class="keyword">public class</span> <span class="type">RegisterRequest</span>
{
    <span class="keyword">public string</span> Username { <span class="keyword">get</span>; <span class="keyword">set</span>; }
    <span class="keyword">public string</span> Email { <span class="keyword">get</span>; <span class="keyword">set</span>; }
    <span class="keyword">public string</span> Password { <span class="keyword">get</span>; <span class="keyword">set</span>; }
}

<span class="keyword">public class</span> <span class="type">RefreshRequest</span>
{
    <span class="keyword">public string</span> RefreshToken { <span class="keyword">get</span>; <span class="keyword">set</span>; }
}

<span class="keyword">public class</span> <span class="type">LogoutRequest</span>
{
    <span class="keyword">public string</span> RefreshToken { <span class="keyword">get</span>; <span class="keyword">set</span>; }
    <span class="comment">// Optional: For web apps that need to redirect after logout</span>
    <span class="keyword">public string</span>? ReturnUrl { <span class="keyword">get</span>; <span class="keyword">set</span>; }
}

<span class="keyword">public class</span> <span class="type">TokenResponse</span>
{
    [<span class="type">JsonPropertyName</span>(<span class="string">"access_token"</span>)]
    <span class="keyword">public string</span> AccessToken { <span class="keyword">get</span>; <span class="keyword">set</span>; }

    [<span class="type">JsonPropertyName</span>(<span class="string">"refresh_token"</span>)]
    <span class="keyword">public string</span> RefreshToken { <span class="keyword">get</span>; <span class="keyword">set</span>; }

    [<span class="type">JsonPropertyName</span>(<span class="string">"expires_in"</span>)]
    <span class="keyword">public int</span> ExpiresIn { <span class="keyword">get</span>; <span class="keyword">set</span>; }

    [<span class="type">JsonPropertyName</span>(<span class="string">"token_type"</span>)]
    <span class="keyword">public string</span> TokenType { <span class="keyword">get</span>; <span class="keyword">set</span>; }

    <span class="comment">// Optional: Return URL for web apps to redirect after login</span>
    <span class="keyword">public string</span>? ReturnUrl { <span class="keyword">get</span>; <span class="keyword">set</span>; }
}
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">5</span>
                    <h3>Create Content Endpoints (Minimal APIs)</h3>
                    <h4>Create ContentEndpoints.cs Extension File</h4>
                    <div class="code-block">
<span class="keyword">namespace</span> YourApp.Endpoints;

<span class="keyword">public static class</span> <span class="type">ContentEndpoints</span>
{
    <span class="keyword">public static</span> <span class="type">WebApplication</span> <span class="function">MapContentEndpoints</span>(<span class="keyword">this</span> <span class="type">WebApplication</span> app)
    {
        <span class="keyword">var</span> group = app.MapGroup(<span class="string">"api/content"</span>)
            .WithTags(<span class="string">"Content"</span>)
            .RequireAuthorization(); <span class="comment">// All endpoints require authentication</span>

        <span class="comment">// GET: api/content - Requires any authenticated user</span>
        group.MapGet(<span class="string">""</span>, () =&gt;
        {
            <span class="keyword">return</span> <span class="type">Results</span>.Ok(<span class="keyword">new</span> { message = <span class="string">"Content data"</span> });
        })
        .WithName(<span class="string">"GetContent"</span>)
        .WithSummary(<span class="string">"Get all content"</span>)
        .Produces(200);

        <span class="comment">// POST: api/content - Requires content.write role</span>
        group.MapPost(<span class="string">""</span>, (<span class="type">ContentDto</span> content) =&gt;
        {
            <span class="keyword">return</span> <span class="type">Results</span>.Ok(<span class="keyword">new</span> { message = <span class="string">"Content created"</span> });
        })
        .RequireAuthorization(<span class="string">"RequireContentWrite"</span>)
        .WithName(<span class="string">"CreateContent"</span>)
        .WithSummary(<span class="string">"Create new content"</span>)
        .Accepts&lt;<span class="type">ContentDto</span>&gt;(<span class="string">"application/json"</span>)
        .Produces(200);

        <span class="comment">// DELETE: api/content/{id} - Requires Admin realm role</span>
        group.MapDelete(<span class="string">"{id:int}"</span>, (<span class="type">int</span> id) =&gt;
        {
            <span class="keyword">return</span> <span class="type">Results</span>.Ok(<span class="keyword">new</span> { message = <span class="string">"Content deleted"</span> });
        })
        .RequireAuthorization(<span class="string">"RequireAdmin"</span>)
        .WithName(<span class="string">"DeleteContent"</span>)
        .WithSummary(<span class="string">"Delete content by ID"</span>)
        .Produces(200);

        <span class="keyword">return</span> app;
    }
}
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">6</span>
                    <h3>Configure Authorization Policies</h3>
                    <p>Authorization policies are configured in <code>Program.cs</code> (shown in step 3 above). The <code>LowCodeHub.Keycloak.Authentication.JwtBearer</code> package includes authorization extension methods:</p>
                    
                    <div class="code-block">
<span class="keyword">using</span> LowCodeHub.Keycloak.Authentication.JwtBearer.Extensions;

<span class="comment">// Authorization policies using LowCodeHub.Keycloak.Authentication.JwtBearer extensions</span>
builder.Services.AddAuthorization(options =&gt;
{
    <span class="comment">// Policy for content.write client role - using RequireResourceRoles extension</span>
    options.AddPolicy(<span class="string">"RequireContentWrite"</span>, policy =&gt;
    {
        policy.RequireResourceRoles(<span class="string">"gps-content-api"</span>, <span class="string">"content.write"</span>);
    });

    <span class="comment">// Policy for content.read client role</span>
    options.AddPolicy(<span class="string">"RequireContentRead"</span>, policy =&gt;
    {
        policy.RequireResourceRoles(<span class="string">"gps-content-api"</span>, <span class="string">"content.read"</span>);
    });

    <span class="comment">// Policy for Admin realm role - using RequireRealmRoles extension</span>
    options.AddPolicy(<span class="string">"RequireAdmin"</span>, policy =&gt;
    {
        policy.RequireRealmRoles(<span class="string">"Admin"</span>);
    });

    <span class="comment">// Combined policy example - chain multiple requirements</span>
    options.AddPolicy(<span class="string">"AdminAndUser"</span>, policy =&gt;
    {
        policy.RequireRealmRoles(<span class="string">"User"</span>); <span class="comment">// Realm role</span>
        policy.RequireResourceRoles(<span class="string">"gps-content-api"</span>, <span class="string">"Admin"</span>); <span class="comment">// Client role</span>
    });

    <span class="comment">// Multiple realm roles example</span>
    options.AddPolicy(<span class="string">"TeacherOrAdmin"</span>, policy =&gt;
    {
        policy.RequireRealmRoles(<span class="string">"Teacher"</span>, <span class="string">"Admin"</span>);
    });

    <span class="comment">// Multiple resource roles example</span>
    options.AddPolicy(<span class="string">"ContentManager"</span>, policy =&gt;
    {
        policy.RequireResourceRoles(
            <span class="string">"gps-content-api"</span>, 
            <span class="string">"content.read"</span>, 
            <span class="string">"content.write"</span>);
    });
});
                    </div>

                    <div class="info-box">
                        <strong>üí° Authorization Extension Features (included in JwtBearer package):</strong>
                        <ul>
                            <li><code>RequireRealmRoles()</code> - Check realm roles (convenient wrapper around RequireClaim)</li>
                            <li><code>RequireResourceRoles()</code> - Check client/resource roles (convenient wrapper around RequireClaim)</li>
                            <li>Clean, readable policy definitions</li>
                            <li>Full integration with ASP.NET Core authorization</li>
                        </ul>
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">7</span>
                    <h3>Package Features Summary</h3>
                    <p>All recommended features have been implemented! Here's what's now available:</p>

                    <h4>‚úÖ Implemented Features</h4>
                    
                    <h5>1. Authorization Package</h5>
                    <p><strong>Status:</strong> ‚úÖ <strong>IMPLEMENTED</strong></p>
                    <p>The <code>LowCodeHub.Keycloak.Authentication.JwtBearer</code> package includes authorization extensions:</p>
                    <ul>
                        <li><code>RequireRealmRoles()</code> extension method</li>
                        <li><code>RequireResourceRoles()</code> extension method</li>
                    </ul>

                    <h5>2. IConfiguration Support</h5>
                    <p><strong>Status:</strong> ‚úÖ <strong>IMPLEMENTED</strong></p>
                    <p>Both packages now support IConfiguration:</p>
                    <ul>
                        <li><code>AddKeycloakClient(IConfiguration, sectionName)</code></li>
                        <li><code>AddKeycloakJwtBearerAuthentication(IConfiguration, sectionName)</code></li>
                        <li>Automatic binding from <code>appsettings.json</code></li>
                    </ul>

                    <h5>3. Configuration Property Mapping</h5>
                    <p><strong>Status:</strong> ‚úÖ <strong>IMPLEMENTED</strong></p>
                    <p>Supports both naming conventions:</p>
                    <ul>
                        <li>Standard names: <code>KeycloakBaseUrl</code>, <code>Realm</code>, <code>Audience</code></li>
                        <li>Keycloak-style names: <code>auth-server-url</code>, <code>resource</code></li>
                        <li>Automatic mapping between conventions</li>
                    </ul>

                    <div class="success-box">
                        <strong>üéâ All Features Complete!</strong> Your LowCodeHub.Keycloak packages now provide a complete, enterprise-ready Keycloak integration solution with all the features needed for production applications.
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">8</span>
                    <h3>Access User Claims in Minimal APIs</h3>
                    <h4>Create UserEndpoints.cs Extension File</h4>
                    <div class="code-block">
<span class="keyword">using</span> LowCodeHub.Keycloak.Client.Clients;
<span class="keyword">using</span> LowCodeHub.Keycloak.Client.Exceptions;
<span class="keyword">using</span> LowCodeHub.Keycloak.Client.Models;
<span class="keyword">using</span> System.Security.Claims;

<span class="keyword">namespace</span> YourApp.Endpoints;

<span class="keyword">public static class</span> <span class="type">UserEndpoints</span>
{
    <span class="keyword">public static</span> <span class="type">WebApplication</span> <span class="function">MapUserEndpoints</span>(<span class="keyword">this</span> <span class="type">WebApplication</span> app)
    {
        <span class="keyword">var</span> group = app.MapGroup(<span class="string">"api/user"</span>)
            .WithTags(<span class="string">"User"</span>)
            .RequireAuthorization();

        <span class="comment">// GET: api/user/profile - Get current user profile</span>
        group.MapGet(<span class="string">"profile"</span>, (<span class="type">ClaimsPrincipal</span> user) =&gt;
        {
            <span class="keyword">var</span> userId = user.FindFirst(<span class="string">"sub"</span>)?.Value;
            <span class="keyword">var</span> username = user.FindFirst(<span class="string">"preferred_username"</span>)?.Value;
            <span class="keyword">var</span> email = user.FindFirst(<span class="string">"email"</span>)?.Value;
            <span class="keyword">var</span> roles = user.FindAll(<span class="string">"realm_access.roles"</span>).Select(c =&gt; c.Value);

            <span class="keyword">return</span> <span class="type">Results</span>.Ok(<span class="keyword">new</span>
            {
                UserId = userId,
                Username = username,
                Email = email,
                Roles = roles
            });
        })
        .WithName(<span class="string">"GetProfile"</span>)
        .WithSummary(<span class="string">"Get current user profile"</span>)
        .Produces(200);

        <span class="comment">// GET: api/user/has-role?role=Admin - Check if user has specific role</span>
        group.MapGet(<span class="string">"has-role"</span>, (<span class="type">string</span> role, <span class="type">ClaimsPrincipal</span> user) =&gt;
        {
            <span class="keyword">var</span> hasRole = user.IsInRole(role);
            
            <span class="keyword">return</span> <span class="type">Results</span>.Ok(<span class="keyword">new</span> { HasRole = hasRole });
        })
        .WithName(<span class="string">"CheckRole"</span>)
        .WithSummary(<span class="string">"Check if user has specific role"</span>)
        .Produces(200);

        <span class="comment">// GET: api/user/info - Get user info from Keycloak using current user's token</span>
        <span class="comment">// The GetUserInfoAsync overload automatically extracts the token from HttpContext</span>
        group.MapGet(<span class="string">"info"</span>, <span class="keyword">async</span> (
            <span class="type">HttpContext</span> httpContext,
            <span class="type">IKeycloakUserClient</span> keycloakUserClient) =&gt;
        {
            <span class="keyword">try</span>
            {
                <span class="comment">// Get user info from Keycloak - token is automatically extracted from cookies or Authorization header</span>
                <span class="keyword">var</span> userInfo = <span class="keyword">await</span> keycloakUserClient.GetUserInfoAsync(httpContext);

                <span class="keyword">return</span> <span class="type">Results</span>.Ok(userInfo);
            }
            <span class="keyword">catch</span> (<span class="type">LoginException</span> ex)
            {
                <span class="keyword">return</span> <span class="type">Results</span>.Unauthorized();
            }
            <span class="keyword">catch</span> (<span class="type">Exception</span> ex)
            {
                <span class="keyword">return</span> <span class="type">Results</span>.Problem(
                    detail: ex.Message,
                    statusCode: 500);
            }
        })
        .WithName(<span class="string">"GetUserInfo"</span>)
        .WithSummary(<span class="string">"Get user information from Keycloak using current user's token"</span>)
        .Produces&lt;<span class="type">KeycloakUserInfo</span>&gt;(200)
        .Produces(401)
        .Produces(500);

        <span class="keyword">return</span> app;
    }
}
                    </div>

                    <div class="info-box">
                        <strong>üí° Endpoint Comparison:</strong>
                        <ul>
                            <li><strong>GET /api/user/profile</strong> - Returns user information from JWT claims (fast, no Keycloak call)</li>
                            <li><strong>GET /api/user/info</strong> - Returns user information directly from Keycloak using the userinfo endpoint (includes all user attributes, roles, etc.)</li>
                        </ul>
                        <p>The <code>/info</code> endpoint calls Keycloak's userinfo endpoint using the current user's access token. The <code>GetUserInfoAsync(HttpContext)</code> method automatically extracts the token from cookies (if enabled) or the Authorization header, making it very easy to use - just pass the HttpContext!</p>
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">9</span>
                    <h3>Built-in Cookie Support</h3>
                    <p>The <code>LowCodeHub.Keycloak</code> package includes <strong>built-in cookie support</strong> that automatically handles cookie management. No manual cookie code needed in your Minimal API endpoints!</p>

                    <div class="success-box">
                        <strong>‚úÖ Built-in Features:</strong>
                        <ul>
                            <li>‚úÖ Automatic cookie setting on login (if enabled)</li>
                            <li>‚úÖ Automatic cookie clearing on logout</li>
                            <li>‚úÖ Automatic Keycloak session invalidation</li>
                            <li>‚úÖ Transparent to Minimal API endpoints - just use <code>LoginWithCookiesAsync</code> and <code>LogoutWithCookiesAsync</code></li>
                            <li>‚úÖ Supports both cookies and Authorization headers (automatic fallback)</li>
                        </ul>
                    </div>

                    <h4>When to Use Cookies</h4>
                    <p>For <strong>web applications</strong> (browsers), using cookies for authentication tokens provides significant security benefits.</p>

                    <h4>When to Use Cookies</h4>
                    <div class="success-box">
                        <strong>‚úÖ Use Cookies For:</strong>
                        <ul>
                            <li><strong>Web Applications</strong> - Traditional server-rendered web apps (MVC, Razor Pages)</li>
                            <li><strong>SPAs (Single Page Applications)</strong> - React, Angular, Vue apps served from the same domain</li>
                            <li><strong>Hybrid Apps</strong> - Apps that need both web and API access</li>
                        </ul>
                    </div>

                    <div class="warning-box">
                        <strong>‚ùå Don't Use Cookies For:</strong>
                        <ul>
                            <li><strong>Mobile Apps</strong> - Use secure storage (Keychain, Keystore) instead</li>
                            <li><strong>API-to-API Communication</strong> - Use Authorization headers</li>
                            <li><strong>Cross-Domain SPAs</strong> - If frontend and backend are on different domains</li>
                        </ul>
                    </div>

                    <h4>Why Cookies Are Useful (Security Benefits)</h4>
                    <div class="info-box">
                        <strong>üîí Security Advantages:</strong>
                        <ul>
                            <li><strong>HttpOnly Flag</strong> - Prevents JavaScript access, protecting against XSS attacks</li>
                            <li><strong>Secure Flag</strong> - Ensures cookies only sent over HTTPS</li>
                            <li><strong>SameSite Attribute</strong> - Prevents CSRF attacks by controlling when cookies are sent</li>
                            <li><strong>Automatic Management</strong> - Browser handles cookie sending automatically</li>
                            <li><strong>No localStorage Risk</strong> - Avoids XSS vulnerabilities from localStorage/sessionStorage</li>
                            <li><strong>Refresh Token Security</strong> - Refresh tokens are safer in HttpOnly cookies than in localStorage</li>
                        </ul>
                    </div>

                    <h4>Implementation: Cookie-Based Token Storage</h4>
                    <p>Add a helper method to set secure cookies for access and refresh tokens:</p>
                    
                    <div class="code-block">
<span class="comment">// Add this helper method to your AuthEndpoints.cs or a separate CookieHelper class</span>
<span class="keyword">private static void</span> <span class="function">SetCookieBasedTokens</span>(
    <span class="type">HttpContext</span> httpContext, 
    <span class="type">KeycloakToken</span> token,
    <span class="type">bool</span> isDevelopment = <span class="keyword">false</span>)
{
    <span class="keyword">var</span> cookieOptions = <span class="keyword">new</span> <span class="type">CookieOptions</span>
    {
        HttpOnly = <span class="keyword">true</span>, <span class="comment">// Prevents JavaScript access (XSS protection)</span>
        Secure = !isDevelopment, <span class="comment">// Only send over HTTPS in production</span>
        SameSite = <span class="type">SameSiteMode</span>.Strict, <span class="comment">// CSRF protection</span>
        Path = <span class="string">"/"</span>,
        <span class="comment">// Set expiration based on token expiration</span>
        Expires = <span class="type">DateTimeOffset</span>.UtcNow.AddSeconds(token.ExpiresIn)
    };

    <span class="comment">// Set access token cookie</span>
    httpContext.Response.Cookies.Append(<span class="string">"access_token"</span>, token.AccessToken, cookieOptions);

    <span class="comment">// Set refresh token cookie (longer expiration)</span>
    <span class="keyword">if</span> (!string.IsNullOrEmpty(token.RefreshToken))
    {
        <span class="keyword">var</span> refreshCookieOptions = <span class="keyword">new</span> <span class="type">CookieOptions</span>
        {
            HttpOnly = <span class="keyword">true</span>,
            Secure = !isDevelopment,
            SameSite = <span class="type">SameSiteMode</span>.Strict,
            Path = <span class="string">"/"</span>,
            <span class="comment">// Refresh tokens typically last 30 days</span>
            Expires = <span class="type">DateTimeOffset</span>.UtcNow.AddDays(30)
        };
        
        httpContext.Response.Cookies.Append(<span class="string">"refresh_token"</span>, token.RefreshToken, refreshCookieOptions);
    }
}

<span class="comment">// Update your login endpoint to optionally set cookies</span>
group.MapPost(<span class="string">"login"</span>, <span class="keyword">async</span> (
    <span class="type">LoginApiRequest</span> request,
    <span class="type">HttpContext</span> httpContext,
    <span class="type">IKeycloakUserClient</span> keycloakUserClient,
    <span class="type">IWebHostEnvironment</span> env) =&gt;
{
    <span class="keyword">try</span>
    {
        <span class="keyword">var</span> loginRequest = <span class="keyword">new</span> <span class="type">LoginRequest</span>
        {
            Username = request.Username,
            Password = request.Password
        };

        <span class="keyword">var</span> keycloakToken = <span class="keyword">await</span> keycloakUserClient.LoginAsync(loginRequest);
        
        <span class="comment">// Option 1: Return tokens in response (for mobile/SPA with different domain)</span>
        <span class="keyword">var</span> tokenResponse = <span class="keyword">new</span> <span class="type">TokenResponse</span>
        {
            AccessToken = keycloakToken.AccessToken,
            RefreshToken = keycloakToken.RefreshToken,
            ExpiresIn = keycloakToken.ExpiresIn,
            TokenType = keycloakToken.TokenType ?? <span class="string">"Bearer"</span>,
            ReturnUrl = request.ReturnUrl
        };

        <span class="comment">// Option 2: Set cookies for web applications (same domain)</span>
        <span class="keyword">if</span> (request.UseCookies) <span class="comment">// Add UseCookies flag to LoginApiRequest</span>
        {
            SetCookieBasedTokens(httpContext, keycloakToken, env.IsDevelopment());
            <span class="comment">// Don't return tokens in response when using cookies</span>
            tokenResponse.AccessToken = <span class="keyword">null</span>;
            tokenResponse.RefreshToken = <span class="keyword">null</span>;
        }
        
        <span class="keyword">return</span> <span class="type">Results</span>.Ok(tokenResponse);
    }
    <span class="keyword">catch</span> (<span class="type">Exception</span> ex)
    {
        <span class="keyword">return</span> <span class="type">Results</span>.Problem(detail: ex.Message, statusCode: 500);
    }
});
                    </div>

                    <h4>How Built-in Cookie Support Works</h4>
                    <p>The package automatically handles all cookie operations based on your configuration:</p>
                    
                    <div class="code-block">
<span class="comment">// 1. Login - Cookies automatically set if CookieOptions.Enabled = true</span>
<span class="keyword">var</span> token = <span class="keyword">await</span> keycloakUserClient.LoginWithCookiesAsync(loginRequest, httpContext);
<span class="comment">// ‚úÖ Cookies are set automatically (access_token, refresh_token)</span>
<span class="comment">// ‚úÖ No manual cookie code needed!</span>

<span class="comment">// 2. GetUserInfo - Automatically reads from cookies or Authorization header</span>
<span class="keyword">var</span> userInfo = <span class="keyword">await</span> keycloakUserClient.GetUserInfoAsync(httpContext);
<span class="comment">// ‚úÖ Tries cookies first, falls back to Authorization header</span>
<span class="comment">// ‚úÖ Works seamlessly for both web apps and mobile/API clients</span>

<span class="comment">// 3. Logout - Cookies cleared and Keycloak sessions invalidated automatically</span>
<span class="keyword">await</span> keycloakUserClient.LogoutWithCookiesAsync(httpContext, keycloakAdminClient, invalidateAllSessions: <span class="keyword">true</span>);
<span class="comment">// ‚úÖ Cookies cleared automatically</span>
<span class="comment">// ‚úÖ Keycloak refresh token invalidated</span>
<span class="comment">// ‚úÖ All Keycloak user sessions invalidated (if admin client provided)</span>
                    </div>

                    <div class="info-box">
                        <strong>üîí Security Benefits of Built-in Cookie Support:</strong>
                        <ul>
                            <li>‚úÖ <strong>Automatic cookie management</strong> - No manual code needed</li>
                            <li>‚úÖ <strong>Secure by default</strong> - HttpOnly, Secure, SameSite configured</li>
                            <li>‚úÖ <strong>Keycloak session invalidation</strong> - Invalidates all user sessions on logout</li>
                            <li>‚úÖ <strong>Immediate invalidation</strong> - Tokens become unusable instantly</li>
                            <li>‚úÖ <strong>Dual support</strong> - Works with cookies AND Authorization headers</li>
                        </ul>
                    </div>

                    <h4>Configuration Options</h4>
                    <p>All cookie behavior is controlled via <code>CookieOptions</code> in your configuration:</p>
                    <div class="code-block">
{
  <span class="string">"KeycloakAdmin"</span>: {
    <span class="string">"CookieOptions"</span>: {
      <span class="string">"Enabled"</span>: <span class="keyword">true</span>, <span class="comment">// Enable/disable cookie support</span>
      <span class="string">"HttpOnly"</span>: <span class="keyword">true</span>, <span class="comment">// Prevent JavaScript access (XSS protection)</span>
      <span class="string">"Secure"</span>: <span class="keyword">true</span>, <span class="comment">// HTTPS only (production)</span>
      <span class="string">"SameSite"</span>: <span class="string">"Strict"</span>, <span class="comment">// CSRF protection</span>
      <span class="string">"AutoSetCookiesOnLogin"</span>: <span class="keyword">true</span>, <span class="comment">// Auto-set on login</span>
      <span class="string">"AutoClearCookiesOnLogout"</span>: <span class="keyword">true</span>, <span class="comment">// Auto-clear on logout</span>
      <span class="string">"InvalidateKeycloakSessionsOnLogout"</span>: <span class="keyword">true</span> <span class="comment">// Invalidate Keycloak sessions</span>
    }
  }
}
                    </div>
                    </div>

                    <h4>Best Practices Summary</h4>
                    <div class="info-box">
                        <strong>üìã Cookie Security Checklist:</strong>
                        <ul>
                            <li>‚úÖ Always use <code>HttpOnly = true</code> to prevent XSS</li>
                            <li>‚úÖ Always use <code>Secure = true</code> in production (HTTPS only)</li>
                            <li>‚úÖ Use <code>SameSite = Strict</code> or <code>Lax</code> for CSRF protection</li>
                            <li>‚úÖ Set appropriate expiration times (short for access tokens, longer for refresh tokens)</li>
                            <li>‚úÖ Use different cookie names for access and refresh tokens</li>
                            <li>‚úÖ Clear cookies on logout</li>
                            <li>‚úÖ Support both cookies and Authorization headers for flexibility</li>
                        </ul>
                    </div>

                    <div class="warning-box">
                        <strong>‚ö†Ô∏è Important Notes:</strong>
                        <ul>
                            <li>Cookies work best when frontend and backend are on the <strong>same domain</strong></li>
                            <li>For cross-domain scenarios, use Authorization headers instead</li>
                            <li>Mobile apps should use secure storage, not cookies</li>
                            <li>Consider using both approaches: cookies for web, headers for mobile/API</li>
                        </ul>
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">10</span>
                    <h3>Handle Unauthorized Requests with ReturnUrl</h3>
                    <p>For web applications, you may want to redirect users to login when they access protected resources, then redirect them back after successful login.</p>

                    <h4>Option 1: Custom Authorization Result Handler (Recommended for Web Apps)</h4>
                    <div class="code-block">
<span class="comment">// In Program.cs, configure unauthorized response handling</span>
builder.Services.Configure&lt;<span class="type">AuthorizationOptions</span>&gt;(options =&gt;
{
    options.FallbackPolicy = options.DefaultPolicy;
});

<span class="comment">// Custom handler for unauthorized requests</span>
builder.Services.ConfigureApplicationCookie(options =&gt;
{
    options.LoginPath = <span class="string">"/login"</span>;
    options.AccessDeniedPath = <span class="string">"/access-denied"</span>;
    options.ReturnUrlParameter = <span class="string">"returnUrl"</span>;
});

<span class="comment">// For Minimal APIs, handle unauthorized in endpoint</span>
app.MapGet(<span class="string">"/protected-page"</span>, (<span class="type">HttpContext</span> context) =&gt;
{
    <span class="keyword">if</span> (!context.User.Identity?.IsAuthenticated ?? <span class="keyword">true</span>)
    {
        <span class="keyword">var</span> returnUrl = context.Request.Path + context.Request.QueryString;
        <span class="keyword">return</span> <span class="type">Results</span>.Redirect(<span class="string">$"/login?returnUrl={Uri.EscapeDataString(returnUrl.ToString())}"</span>);
    }
    
    <span class="keyword">return</span> <span class="type">Results</span>.Ok(<span class="keyword">new</span> { message = <span class="string">"Protected content"</span> });
})
.RequireAuthorization(); <span class="comment">// This will return 401 if not authenticated</span>
                    </div>

                    <h4>Option 2: Handle 401 Responses in Frontend</h4>
                    <div class="code-block">
<span class="comment">// JavaScript/TypeScript example for handling unauthorized responses</span>
<span class="keyword">async function</span> <span class="function">apiCall</span>(url, options = {}) {
    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url, {
        ...options,
        headers: {
            ...options.headers,
            <span class="string">'Authorization'</span>: <span class="string">`Bearer ${getAccessToken()}`</span>
        }
    });

    <span class="keyword">if</span> (response.status === 401) {
        <span class="comment">// Token expired or invalid, redirect to login with returnUrl</span>
        <span class="keyword">const</span> returnUrl = encodeURIComponent(window.location.pathname + window.location.search);
        window.location.href = <span class="string">`/login?returnUrl=${returnUrl}`</span>;
        <span class="keyword">return</span>;
    }

    <span class="keyword">return</span> response;
}
                    </div>

                    <h4>Option 3: Configure Unauthorized Response Handler for Minimal APIs</h4>
                    <div class="code-block">
<span class="comment">// In Program.cs, configure how unauthorized requests are handled</span>
builder.Services.Configure&lt;<span class="type">AuthorizationOptions</span>&gt;(options =&gt;
{
    options.FallbackPolicy = options.DefaultPolicy;
});

<span class="comment">// Custom unauthorized handler for Minimal APIs</span>
builder.Services.ConfigureApplicationCookie(options =&gt;
{
    options.LoginPath = <span class="string">"/login"</span>;
    options.AccessDeniedPath = <span class="string">"/access-denied"</span>;
    options.ReturnUrlParameter = <span class="string">"returnUrl"</span>;
});

<span class="comment">// For Minimal APIs, you can create a custom result handler</span>
app.Use(async (context, next) =&gt;
{
    <span class="keyword">await</span> next();
    
    <span class="comment">// If 401 and it's a web page request, redirect to login</span>
    <span class="keyword">if</span> (context.Response.StatusCode == 401 
        && context.Request.Headers.Accept.ToString().Contains(<span class="string">"text/html"</span>))
    {
        <span class="keyword">var</span> returnUrl = context.Request.Path + context.Request.QueryString;
        context.Response.Redirect(<span class="string">$"/login?returnUrl={Uri.EscapeDataString(returnUrl.ToString())}"</span>);
    }
});
                    </div>

                    <div class="info-box">
                        <strong>üí° Best Practice:</strong> For API endpoints (JSON), return 401 status. For web pages (HTML), redirect to login with returnUrl. Minimal APIs automatically return 401 for unauthorized requests, which you can handle in middleware or frontend.
                    </div>

                    <h4>Security: Validate ReturnUrl to Prevent Open Redirects</h4>
                    <div class="code-block">
<span class="comment">// Always validate returnUrl to prevent open redirect vulnerabilities</span>
<span class="keyword">private bool</span> <span class="function">IsValidReturnUrl</span>(<span class="type">string</span> returnUrl)
{
    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(returnUrl))
        <span class="keyword">return</span> <span class="keyword">false</span>;

    <span class="comment">// Only allow relative URLs or URLs from your own domain</span>
    <span class="keyword">if</span> (<span class="type">Uri</span>.TryCreate(returnUrl, <span class="type">UriKind</span>.Relative, <span class="keyword">out</span> <span class="type">Uri</span> relativeUri))
    {
        <span class="comment">// Relative URL is safe</span>
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="keyword">if</span> (<span class="type">Uri</span>.TryCreate(returnUrl, <span class="type">UriKind</span>.Absolute, <span class="keyword">out</span> <span class="type">Uri</span> absoluteUri))
    {
        <span class="comment">// Only allow URLs from your own domain</span>
        <span class="keyword">var</span> allowedDomains = <span class="keyword">new</span>[] { <span class="string">"yourdomain.com"</span>, <span class="string">"www.yourdomain.com"</span> };
        <span class="keyword">return</span> allowedDomains.Contains(absoluteUri.Host, <span class="type">StringComparer</span>.OrdinalIgnoreCase);
    }

    <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="comment">// Use in login method</span>
<span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(request.ReturnUrl) && !<span class="function">IsValidReturnUrl</span>(request.ReturnUrl))
{
    request.ReturnUrl = <span class="keyword">null</span>; <span class="comment">// Ignore invalid returnUrl</span>
}
                    </div>

                    <div class="danger-box">
                        <strong>üîí Security Warning:</strong> Never redirect to arbitrary URLs from returnUrl without validation. This can lead to open redirect vulnerabilities where attackers can redirect users to malicious sites. Always validate that returnUrl is relative or from your own domain.
                    </div>
                </div>

                <div class="step">
                    <span class="step-number">10</span>
                    <h3>Logout Implementation Details</h3>
                    <p>The logout endpoint invalidates the refresh token in Keycloak, effectively logging out the user from all sessions if using SSO.</p>

                    <h4>Client-Side Logout Flow:</h4>
                    <div class="code-block">
<span class="comment">// JavaScript/TypeScript example</span>
<span class="keyword">async function</span> <span class="function">logout</span>(returnUrl = <span class="string">'/'</span>) {
    <span class="keyword">const</span> refreshToken = localStorage.getItem(<span class="string">'refreshToken'</span>);
    
    <span class="keyword">if</span> (!refreshToken) {
        <span class="comment">// No token, just clear local storage and redirect</span>
        localStorage.clear();
        window.location.href = returnUrl;
        <span class="keyword">return</span>;
    }

    <span class="keyword">try</span> {
        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'/api/auth/logout'</span>, {
            method: <span class="string">'POST'</span>,
            headers: {
                <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,
                <span class="string">'Authorization'</span>: <span class="string">`Bearer ${localStorage.getItem('accessToken')}`</span>
            },
            body: <span class="type">JSON</span>.stringify({
                refreshToken: refreshToken,
                returnUrl: returnUrl
            })
        });

        <span class="keyword">if</span> (response.ok) {
            <span class="comment">// Clear local storage</span>
            localStorage.clear();
            sessionStorage.clear();
            
            <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();
            <span class="comment">// Redirect to returnUrl if provided</span>
            window.location.href = data.returnUrl || returnUrl;
        }
    } <span class="keyword">catch</span> (error) {
        <span class="comment">// Even if logout fails, clear local tokens</span>
        localStorage.clear();
        sessionStorage.clear();
        window.location.href = returnUrl;
    }
}
                    </div>

                    <h4>Mobile App Logout:</h4>
                    <div class="code-block">
<span class="comment">// C# Xamarin/MAUI example</span>
<span class="keyword">public async Task</span> <span class="function">LogoutAsync</span>(<span class="type">string</span> returnUrl = <span class="string">null</span>)
{
    <span class="keyword">var</span> refreshToken = <span class="keyword">await</span> SecureStorage.GetAsync(<span class="string">"refresh_token"</span>);
    
    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(refreshToken))
    {
        <span class="keyword">try</span>
        {
            <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.PostAsync(<span class="string">"/api/auth/logout"</span>, 
                <span class="keyword">new</span> <span class="type">StringContent</span>(<span class="type">JsonSerializer</span>.Serialize(<span class="keyword">new</span> 
                {
                    RefreshToken = refreshToken,
                    ReturnUrl = returnUrl
                }), <span class="type">Encoding</span>.UTF8, <span class="string">"application/json"</span>));
        }
        <span class="keyword">catch</span> { }
    }

    <span class="comment">// Clear secure storage</span>
    SecureStorage.Remove(<span class="string">"access_token"</span>);
    SecureStorage.Remove(<span class="string">"refresh_token"</span>);
    
    <span class="comment">// Navigate to login page</span>
    <span class="keyword">await</span> Shell.Current.GoToAsync(<span class="string">"//login"</span>);
}
                    </div>

                    <div class="warning-box">
                        <strong>‚ö†Ô∏è Security Note:</strong> Always clear tokens from client storage (localStorage, sessionStorage, SecureStorage) even if the logout API call fails. This ensures tokens are removed from the device.
                    </div>
                </div>
            </section>

            <section id="best-practices">
                <h2>‚≠ê Best Practices</h2>

                <div class="step">
                    <h3>1. Security Best Practices</h3>
                    <ul>
                        <li><strong>Never expose Keycloak URLs to clients:</strong> All Keycloak communication should go through your backend</li>
                        <li><strong>Use HTTPS in production:</strong> Always use HTTPS for Keycloak and your API</li>
                        <li><strong>Store secrets securely:</strong> Use Azure Key Vault, AWS Secrets Manager, or environment variables</li>
                        <li><strong>Short token lifespans:</strong> Keep access tokens short (5-15 minutes) and use refresh tokens</li>
                        <li><strong>Validate audience:</strong> Always validate the audience claim in tokens</li>
                        <li><strong>Principle of least privilege:</strong> Only assign minimum required roles</li>
                    </ul>
                </div>

                <div class="step">
                    <h3>2. Token Management</h3>
                    <ul>
                        <li><strong>Cache tokens:</strong> Cache service account tokens to reduce Keycloak load</li>
                        <li><strong>Handle token refresh:</strong> Implement automatic refresh before expiration</li>
                        <li><strong>Store tokens securely:</strong> Use secure storage (Keychain on iOS, Keystore on Android)</li>
                        <li><strong>Never log tokens:</strong> Avoid logging access tokens or refresh tokens</li>
                    </ul>
                </div>

                <div class="step">
                    <h3>3. Error Handling</h3>
                    <div class="code-block">
<span class="keyword">try</span>
{
    <span class="comment">// Keycloak operation</span>
}
<span class="keyword">catch</span> (<span class="type">KeycloakException</span> ex) <span class="keyword">when</span> (ex.StatusCode == 401)
{
    <span class="comment">// Handle unauthorized</span>
    <span class="keyword">return</span> Unauthorized();
}
<span class="keyword">catch</span> (<span class="type">KeycloakException</span> ex) <span class="keyword">when</span> (ex.StatusCode == 403)
{
    <span class="comment">// Handle forbidden</span>
    <span class="keyword">return</span> Forbid();
}
<span class="keyword">catch</span> (<span class="type">Exception</span> ex)
{
    <span class="comment">// Log and return generic error</span>
    _logger.LogError(ex, <span class="string">"Keycloak operation failed"</span>);
    <span class="keyword">return</span> StatusCode(500, <span class="string">"Internal server error"</span>);
}
                    </div>
                </div>

                <div class="step">
                    <h3>4. Performance Optimization</h3>
                    <ul>
                        <li><strong>Token caching:</strong> Cache validated tokens to avoid repeated validation</li>
                        <li><strong>Connection pooling:</strong> Reuse HTTP connections to Keycloak</li>
                        <li><strong>Async operations:</strong> Always use async/await for Keycloak operations</li>
                        <li><strong>Bulk operations:</strong> Use bulk APIs when managing multiple users</li>
                    </ul>
                </div>

                <div class="step">
                    <h3>5. Monitoring & Logging</h3>
                    <ul>
                        <li><strong>Log authentication events:</strong> Track login attempts, failures, successes</li>
                        <li><strong>Monitor token validation:</strong> Track token validation performance</li>
                        <li><strong>Alert on failures:</strong> Set up alerts for Keycloak connectivity issues</li>
                        <li><strong>Audit user operations:</strong> Log all user management operations</li>
                    </ul>
                </div>
            </section>

            <section id="enterprise-patterns">
                <h2>üè¢ Enterprise Patterns</h2>

                <div class="step">
                    <h3>1. Multi-Tenant Architecture</h3>
                    <p>For SaaS applications, use separate realms or client scopes per tenant.</p>
                    <ul>
                        <li><strong>Option A:</strong> One realm per tenant (complete isolation)</li>
                        <li><strong>Option B:</strong> One realm with client scopes per tenant (shared infrastructure)</li>
                        <li><strong>Option C:</strong> One realm with groups per tenant (most cost-effective)</li>
                    </ul>
                </div>

                <div class="step">
                    <h3>2. Role-Based Access Control (RBAC)</h3>
                    <ul>
                        <li><strong>Realm roles:</strong> Global permissions (Admin, User, Guest)</li>
                        <li><strong>Client roles:</strong> Feature-specific permissions (content.read, content.write)</li>
                        <li><strong>Composite roles:</strong> Roles that include other roles</li>
                        <li><strong>Role hierarchies:</strong> Senior roles inherit permissions from junior roles</li>
                    </ul>
                </div>

                <div class="step">
                    <h3>3. Attribute-Based Access Control (ABAC)</h3>
                    <p>Use custom claims and policies for fine-grained access control.</p>
                    <div class="code-block">
<span class="comment">// Add custom attribute to user using Keycloak Admin API</span>
<span class="comment">// Note: Use Keycloak.AuthServices.Sdk to interact with Admin API</span>
<span class="comment">// Example using IKeycloakRealmClient (check SDK documentation for exact API)</span>

<span class="comment">// Option 1: Using SDK methods (if available)</span>
<span class="comment">// var user = await keycloakRealmClient.GetUserAsync(userId);</span>
<span class="comment">// user.Attributes = new Dictionary&lt;string, IList&lt;string&gt;&gt;</span>
<span class="comment">// {</span>
<span class="comment">//     { "department", new List&lt;string&gt; { "Engineering" } },</span>
<span class="comment">//     { "region", new List&lt;string&gt; { "US" } }</span>
<span class="comment">// };</span>
<span class="comment">// await keycloakRealmClient.UpdateUserAsync(userId, user);</span>

<span class="comment">// Option 2: Using HTTP client directly</span>
<span class="comment">// POST /admin/realms/{realm}/users/{userId}</span>
<span class="comment">// Body: { "attributes": { "department": ["Engineering"], "region": ["US"] } }</span>

<span class="comment">// Then use these attributes in authorization policies</span>
builder.Services.AddAuthorization(options =&gt;
{
    options.AddPolicy(<span class="string">"EngineeringOnly"</span>, policy =&gt;
    {
        policy.RequireClaim(<span class="string">"department"</span>, <span class="string">"Engineering"</span>);
    });
});
                    </div>

                    <div class="info-box">
                        <strong>üí° SDK Reference:</strong> For detailed Admin API usage, refer to the <a href="https://github.com/NikiforovAll/keycloak-authorization-services-dotnet" target="_blank">Keycloak.AuthServices.Sdk documentation</a> for the exact API methods and interfaces available.
                    </div>
                </div>

                <div class="step">
                    <h3>4. Single Sign-On (SSO)</h3>
                    <p>Keycloak supports SSO across multiple applications:</p>
                    <ul>
                        <li>Users login once and access multiple applications</li>
                        <li>Session sharing across applications in the same realm</li>
                        <li>Automatic token refresh across applications</li>
                    </ul>
                </div>

                <div class="step">
                    <h3>5. Identity Federation</h3>
                    <p>Integrate with external identity providers:</p>
                    <ul>
                        <li><strong>Social login:</strong> Google, Facebook, Microsoft, etc.</li>
                        <li><strong>SAML:</strong> Enterprise SSO (Active Directory, Okta)</li>
                        <li><strong>LDAP/Active Directory:</strong> Sync users from corporate directory</li>
                    </ul>
                </div>

                <div class="step">
                    <h3>6. High Availability & Clustering</h3>
                    <ul>
                        <li><strong>Keycloak clustering:</strong> Run multiple Keycloak instances</li>
                        <li><strong>Database:</strong> Use PostgreSQL or MySQL (not embedded H2)</li>
                        <li><strong>Load balancing:</strong> Use load balancer in front of Keycloak</li>
                        <li><strong>Session replication:</strong> Configure Infinispan for session sharing</li>
                    </ul>
                </div>
            </section>

            <section id="troubleshooting">
                <h2>üîç Troubleshooting</h2>

                <div class="step">
                    <h3>Common Issues & Solutions</h3>

                    <h4>1. "Invalid token" errors</h4>
                    <ul>
                        <li>Check token expiration</li>
                        <li>Verify audience matches client ID</li>
                        <li>Ensure Keycloak URL is correct</li>
                        <li>Check token signature validation</li>
                    </ul>

                    <h4>2. "Client authentication failed"</h4>
                    <ul>
                        <li>Verify client secret is correct</li>
                        <li>Check client authentication is enabled</li>
                        <li>Ensure service account is enabled</li>
                    </ul>

                    <h4>3. "User not found"</h4>
                    <ul>
                        <li>Verify user exists in correct realm</li>
                        <li>Check user is enabled</li>
                        <li>Verify username/email is correct</li>
                    </ul>

                    <h4>4. "Insufficient permissions"</h4>
                    <ul>
                        <li>Check user has required roles</li>
                        <li>Verify roles are assigned to correct client</li>
                        <li>Check service account has required permissions</li>
                    </ul>

                    <h4>5. Performance issues</h4>
                    <ul>
                        <li>Enable token caching</li>
                        <li>Use connection pooling</li>
                        <li>Consider Keycloak clustering</li>
                        <li>Optimize database queries</li>
                    </ul>

                    <h4>6. Logout not working</h4>
                    <ul>
                        <li>Verify refresh token is being sent in logout request</li>
                        <li>Check that refresh token hasn't expired</li>
                        <li>Ensure client secret is correct for logout endpoint</li>
                        <li>Verify logout endpoint URL is correct</li>
                        <li>Check Keycloak logs for logout errors</li>
                        <li>For SSO scenarios, ensure logout propagates to all applications</li>
                    </ul>

                    <h4>7. ReturnUrl not working</h4>
                    <ul>
                        <li>Verify returnUrl is URL-encoded when passed as query parameter</li>
                        <li>Check that returnUrl is validated to prevent open redirect vulnerabilities</li>
                        <li>Ensure returnUrl is relative or from allowed domains</li>
                        <li>For SPAs, handle returnUrl in frontend routing logic</li>
                        <li>Check browser console for JavaScript errors during redirect</li>
                    </ul>
                </div>

                <div class="step">
                    <h3>Debugging Tips</h3>
                    <ul>
                        <li><strong>Enable Keycloak logging:</strong> Set log level to DEBUG in Keycloak</li>
                        <li><strong>Inspect JWT tokens:</strong> Use jwt.io to decode and inspect tokens</li>
                        <li><strong>Check Keycloak events:</strong> Review events in Admin Console</li>
                        <li><strong>Network inspection:</strong> Use Fiddler/Postman to inspect HTTP requests</li>
                        <li><strong>ASP.NET Core logging:</strong> Enable detailed logging for authentication</li>
                    </ul>
                </div>

                <div class="step">
                    <h3>Useful Keycloak Endpoints</h3>
                    <table>
                        <tr>
                            <th>Endpoint</th>
                            <th>Purpose</th>
                        </tr>
                        <tr>
                            <td>/realms/{realm}/.well-known/openid-configuration</td>
                            <td>OpenID Connect discovery document</td>
                        </tr>
                        <tr>
                            <td>/realms/{realm}/protocol/openid-connect/token</td>
                            <td>Token endpoint (login, refresh)</td>
                        </tr>
                        <tr>
                            <td>/realms/{realm}/protocol/openid-connect/userinfo</td>
                            <td>Get user information</td>
                        </tr>
                        <tr>
                            <td>/realms/{realm}/protocol/openid-connect/logout</td>
                            <td>Logout endpoint</td>
                        </tr>
                    </table>
                </div>
            </section>

            <section>
                <h2>üìö Additional Resources</h2>
                
                <h3>LowCodeHub Keycloak Packages</h3>
                <ul>
                    <li><strong>LowCodeHub.Keycloak</strong> - Comprehensive Keycloak Admin API client and user authentication</li>
                    <li><strong>LowCodeHub.Keycloak.Authentication.JwtBearer</strong> - JWT Bearer authentication with Keycloak</li>
                    <li>See <code>LowCodeHub-Keycloak-Packages-Analysis.md</code> for detailed feature analysis and recommendations</li>
                </ul>

                <h3>Keycloak Resources</h3>
                <ul>
                    <li><a href="https://www.keycloak.org/documentation" target="_blank">Keycloak Official Documentation</a></li>
                    <li><a href="https://github.com/keycloak/keycloak" target="_blank">Keycloak GitHub Repository</a></li>
                    <li><a href="https://www.keycloak.org/docs/latest/securing_apps/" target="_blank">Securing Applications Guide</a></li>
                </ul>

                <h3>Standards & Specifications</h3>
                <ul>
                    <li><a href="https://openid.net/specs/openid-connect-core-1_0.html" target="_blank">OpenID Connect Specification</a></li>
                    <li><a href="https://oauth.net/2/" target="_blank">OAuth 2.0 Documentation</a></li>
                </ul>

                <h3>Alternative Packages (Reference)</h3>
                <ul>
                    <li><a href="https://github.com/NikiforovAll/keycloak-authorization-services-dotnet" target="_blank">Keycloak.AuthServices</a> - Alternative .NET integration for Keycloak</li>
                    <li>Useful for comparing features and implementation approaches</li>
                </ul>

                <div class="info-box">
                    <strong>üí° Package Information:</strong> This guide uses the <strong>LowCodeHub.Keycloak</strong> packages, which provide comprehensive Keycloak integration with excellent Admin API coverage. The packages offer extensive user management, role management, and authentication capabilities. For feature analysis and recommendations on enhancements, see <code>LowCodeHub-Keycloak-Packages-Analysis.md</code>.
                </div>
            </section>
        </div>
    </div>

    <div class="back-to-top" id="backToTop" onclick="scrollToTop()">‚Üë</div>

    <script>
        // Show/hide back to top button
        window.addEventListener('scroll', function() {
            const backToTop = document.getElementById('backToTop');
            if (window.pageYOffset > 300) {
                backToTop.style.display = 'block';
            } else {
                backToTop.style.display = 'none';
            }
        });

        // Smooth scroll to top
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        // Smooth scroll for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Syntax highlighting helper (basic)
        document.addEventListener('DOMContentLoaded', function() {
            const codeBlocks = document.querySelectorAll('.code-block');
            codeBlocks.forEach(block => {
                block.style.position = 'relative';
            });
        });
    </script>
</body>
</html>